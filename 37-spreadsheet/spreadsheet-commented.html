<!-- ===== ENGLISH VERSION ===== -->

<!DOCTYPE html>
<!-- ğŸ¯ HTML5 DECLARATION: "Welcome to homemade Excel!" -->
<!-- It's like opening the doors of a digital accounting office! ğŸ“Š -->

<html lang="en">
<!-- ğŸŒ MAIN CONTAINER: Our web spreadsheet -->
<!-- lang="en" = English, the universal language of numbers! ğŸ’° -->

  <head>
    <!-- ğŸ§  THE MATH BRAIN: Where we prepare the formulas -->
    <!-- It's like the back of a calculator where the circuits live! -->
    
    <meta charset="utf-8" />
    <!-- ğŸ“ UNIVERSAL CHARACTERS: UTF-8 for numbers and mathematical symbols âˆ‘âˆâˆ« -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- ğŸ“± RESPONSIVE DESIGN: "The spreadsheet adapts to every screen!" -->
    <!-- It's like having a notebook that magically changes size -->
    
    <title>Functional Programming Spreadsheet</title>
    <!-- ğŸ“‘ TITLE: A spreadsheet that uses functional programming! -->
    
    <style>
      /* ğŸ¨ ===== STYLES FOR OUR EXCEL ===== */
      
      #container {
        display: grid;
        /* ğŸ¯ CSS GRID: The perfect layout for a spreadsheet! */
        
        grid-template-columns: 50px repeat(10, 200px);
        /* ğŸ“ COLUMNS: First column 50px (for row numbers), then 10 columns of 200px */
        /* repeat(10, 200px) = repeat "200px" 10 times */
        /* It's like saying: narrow labels, wide cells for data */
        
        grid-template-rows: repeat(11, 30px);
        /* ğŸ“ ROWS: 11 rows of 30px each */
        /* First row for letters A-J, then 10 rows for data */
      }
      
      .label {
        background-color: lightgray;
        /* ğŸ”˜ GRAY BACKGROUND: To distinguish labels */
        
        text-align: center;
        /* âš–ï¸ CENTERED TEXT: Letters and numbers centered */
        
        vertical-align: middle;
        /* ğŸ“ VERTICAL ALIGNMENT: Center vertically */
        
        line-height: 30px;
        /* ğŸ“ LINE HEIGHT: Trick to vertically center! */
        /* line-height = row height = centers perfectly */
      }
    </style>
  </head>
  
  <body>
    <!-- ğŸ“Š ===== THE SPREADSHEET COMES TO LIFE! ===== -->
    
    <div id="container">
      <!-- ğŸ“¦ GRID CONTAINER: Everything will be built here dynamically -->
      <div></div>
      <!-- ğŸ“ EMPTY DIV: For the top-left corner (above the row numbers) -->
    </div>
    
    <script>
      /* ğŸ§® ===== THE MATHEMATICAL ENGINE OF THE SPREADSHEET ===== */
      
      const infixToFunction = {
        "+": (x, y) => x + y,
        "-": (x, y) => x - y,
        "*": (x, y) => x * y,
        "/": (x, y) => x / y,
      }
      /* ğŸ”¢ OPERATOR DICTIONARY: Maps symbols to mathematical functions */
      /* It's like having a manual that says: */
      /* "+" means "add these two numbers" */
      /* "-" means "subtract the second from the first" */
      /* Arrow function (x, y) => x + y is like saying "take x and y, return the sum" */
      
      const infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));
      /* ğŸ¯ EXPRESSION EVALUATOR: Finds math patterns and computes them! */
      /* str.replace(regex, callback) = find the pattern and replace it */
      /* _match = the entire match (underscore indicates we don't use it) */
      /* arg1, operator, arg2 = captured pieces from the regex (e.g. "5", "+", "3") */
      /* parseFloat() = convert string to decimal number */
      /* It's like a robot that finds "5+3" and replaces it with "8" */
      
      const highPrecedence = str => {
        const regex = /([\d.]+)([*\\/])([\d.]+)/;
        /* ğŸ“ REGEX FOR MULTIPLICATION/DIVISION: */
        /* ([\d.]+) = one or more digits/dots (first number) */
        /* ([*\\/]) = * or / (operator) */
        /* ([\d.]+) = second number */
        /* Finds patterns like "5*3" or "10/2" */
        
        const str2 = infixEval(str, regex);
        /* ğŸ”„ EVALUATE: Apply multiplications and divisions */
        
        return str === str2 ? str : highPrecedence(str2);
        /* ğŸ” RECURSION: If nothing changed, we're done! Otherwise, continue */
        /* It's like saying: "keep doing * and / until none remain" */
        /* Recursion = the function calls itself */
      }
      
      /* ğŸ§® ===== BASIC MATH FUNCTIONS ===== */
      
      const isEven = num => num % 2 === 0;
      /* ğŸ”¢ IS IT EVEN?: num % 2 = remainder of division by 2 */
      /* If remainder is 0, the number is even! */
      /* 4 % 2 = 0 (even), 5 % 2 = 1 (odd) */
      
      const sum = nums => nums.reduce((acc, el) => acc + el, 0);
      /* â• SUM: reduce() accumulates all values */
      /* acc = accumulator (starts at 0) */
      /* el = current element */
      /* It's like having a calculator that presses + for every number */
      
      const average = nums => sum(nums) / nums.length;
      /* ğŸ“Š AVERAGE: Sum all and divide by how many there are */
      /* It's the classic arithmetic mean we used in school! */
      
      const median = nums => {
        const sorted = nums.slice().sort((a, b) => a - b);
        /* ğŸ”„ COPY AND SORT: slice() creates a copy, sort() orders it */
        /* (a, b) => a - b sorts in ascending order */
        /* We don't modify the original array! */
        
        const length = sorted.length;
        const middle = length / 2 - 1;
        /* ğŸ“ FIND THE CENTER: -1 because arrays start at 0 */
        
        return isEven(length)
          ? average([sorted[middle], sorted[middle + 1]])
          : sorted[Math.ceil(middle)];
        /* ğŸ¯ MEDIAN: */
        /* If even: average of the two central values */
        /* If odd: the central one */
        /* Math.ceil() = round up */
      }
      
      /* ğŸ“š ===== DICTIONARY OF SPREADSHEET FUNCTIONS ===== */
      
      const spreadsheetFunctions = {
        "" : (nums) => nums,
        /* ğŸ”„ EMPTY FUNCTION: Returns numbers as they are */
        
        sum,
        /* â• SUM: Uses the function defined above */
        /* Shorthand for sum: sum (instead of sum: sum) */
        
        average,
        /* ğŸ“Š AVERAGE: Arithmetic mean */
        
        median,
        /* ğŸ“ˆ MEDIAN: Central value */
        
        even: nums => nums.filter(isEven),
        /* ğŸ”¢ ONLY EVENS: filter() keeps only those that pass the test */
        
        someeven: nums => nums.some(isEven),
        /* â“ AT LEAST ONE EVEN?: some() = true if at least one is even */
        
        everyeven: nums => nums.every(isEven),
        /* âœ… ALL EVEN?: every() = true only if ALL are even */
        
        firsttwo: nums => nums.slice(0, 2),
        /* âœŒï¸ FIRST TWO: slice(0, 2) = from index 0 to 2 (excluded) */
        
        lasttwo: nums => nums.slice(-2),
        /* ğŸ”š LAST TWO: slice(-2) = the last 2 elements */
        /* Negative indices start from the end! */
        
        has2: nums => nums.includes(2),
        /* ğŸ” CONTAINS 2?: includes() looks for a specific value */
        
        increment: nums => nums.map(num => num + 1),
        /* â•1ï¸âƒ£ INCREMENT: map() transforms each element */
        /* Adds 1 to every number */
        
        random: ([x, y]) => Math.floor(Math.random() * y + x),
        /* ğŸ² RANDOM NUMBER: Between x and y */
        /* [x, y] = destructuring, takes the first two elements */
        /* Math.random() = number between 0 and 1 */
        /* Math.floor() = round down */
        
        range: nums => range(...nums),
        /* ğŸ”¢ SEQUENCE: Creates a range of numbers */
        /* ...nums = spread operator, "unpacks" the array */
        
        nodupes: nums => [...new Set(nums).values()]
        /* ğŸš« NO DUPLICATES: Set automatically removes duplicates! */
        /* [...] = spread to convert back to array */
        /* It's like passing the numbers through a sieve that keeps only one of each */
      }
      
      /* ğŸ¯ ===== FUNCTION APPLICATOR ===== */
      
      const applyFunction = str => {
        const noHigh = highPrecedence(str);
        /* ğŸ¥‡ PRIORITIES FIRST: Solve * and / before + and - */
        
        const infix = /([\d.]+)([+-])([\d.]+)/;
        /* ğŸ“ ADDITION/SUBTRACTION REGEX: Pattern for + and - */
        
        const str2 = infixEval(noHigh, infix);
        /* ğŸ”„ EVALUATE: Now solve + and - */
        
        const functionCall = /([a-z0-9]*)\(([0-9., ]*)\)(?!.*\()/i;
        /* ğŸ” FUNCTION CALL REGEX: */
        /* ([a-z0-9]*) = function name (letters/numbers) */
        /* \( = literal open parenthesis */
        /* ([0-9., ]*) = arguments (numbers, commas, spaces) */
        /* \) = closing parenthesis */
        /* (?!.*\() = negative lookahead: there must not be another ( after */
        /* i at the end = case insensitive */
        /* Finds the last nested function to evaluate */
        
        const toNumberList = args => args.split(",").map(parseFloat);
        /* ğŸ”¢ CONVERT TO NUMBERS: "1,2,3" becomes [1, 2, 3] */
        /* split(",") = split on comma */
        /* map(parseFloat) = convert each piece to a number */
        
        const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));
        /* ğŸ¯ APPLY FUNCTION: */
        /* toLowerCase() = sum, SUM, Sum are all the same */
        /* Looks up the function in the dictionary and executes it */
        
        return str2.replace(functionCall, (match, fn, args) => 
          spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match
        );
        /* ğŸ”„ REPLACE: If the function exists, compute it; otherwise leave as is */
        /* hasOwnProperty() = checks if the property exists */
        /* ? : = ternary operator (inline if) */
      }
      
      /* ğŸ”¢ ===== RANGE GENERATORS ===== */
      
      const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);
      /* ğŸ”¢ CREATE NUMERIC SEQUENCE: From start to end (inclusive) */
      /* Array(n) = creates an array of n elements */
      /* fill(start) = fill everything with start */
      /* map((el, i) => el + i) = transform each element to start + position */
      /* range(5, 8) = [5, 6, 7, 8] */
      /* It's like counting on your fingers from start to end! */
      
      const charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));
      /* ğŸ”¤ CREATE LETTER SEQUENCE: From start to end */
      /* charCodeAt(0) = ASCII code of the first letter */
      /* String.fromCharCode() = from ASCII code to letter */
      /* charRange("A", "D") = ["A", "B", "C", "D"] */
      /* It's like reciting the alphabet from one letter to another! */
      
      /* ğŸ§® ===== THE HEART: FORMULA EVALUATOR ===== */
      
      const evalFormula = (x, cells) => {
        const idToText = id => cells.find(cell => cell.id === id).value;
        /* ğŸ” FIND CELL VALUE: Look up the cell with that ID and take its value */
        /* find() = finds the first element that satisfies the condition */
        
        const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;
        /* ğŸ“ RANGE REGEX: A1:B3 */
        /* ([A-J]) = first letter (A-J) */
        /* ([1-9][0-9]?) = number 1-99 (? = optional) */
        /* : = literal colon */
        /* Same for the second cell */
        /* gi = global (all matches) + case insensitive */
        
        const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));
        /* ğŸ”¢ NUMBERS FROM STRING: "1" and "3" become [1, 2, 3] */
        
        const elemValue = num => character => idToText(character + num);
        /* ğŸ¯ ELEMENT VALUE: Curried function! */
        /* First take the number, then the letter, then find the value */
        /* elemValue(1)("A") = value of cell A1 */
        /* Currying = a function that returns a function */
        
        const addCharacters = character1 => character2 => num => 
          charRange(character1, character2).map(elemValue(num));
        /* ğŸ”¤ ADD CHARACTERS: Triple curry! */
        /* addCharacters("A")("C")(1) = values of A1, B1, C1 */
        /* It's like a chain of function assembly lines */
        
        const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => 
          rangeFromString(num1, num2).map(addCharacters(char1)(char2))
        );
        /* ğŸ”„ EXPAND RANGE: A1:B2 becomes A1,B1,A2,B2 */
        /* Transforms ranges into lists of cells */
        
        const cellRegex = /[A-J][1-9][0-9]?/gi;
        /* ğŸ“ SINGLE CELL REGEX: A1, B2, etc. */
        
        const cellExpanded = rangeExpanded.replace(cellRegex, match => 
          idToText(match.toUpperCase())
        );
        /* ğŸ”„ REPLACE CELLS: A1 becomes its value */
        
        const functionExpanded = applyFunction(cellExpanded);
        /* ğŸ¯ APPLY FUNCTIONS: Compute sum(), average(), etc. */
        
        return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);
        /* ğŸ” RECURSION: If nothing changed, we're done! */
        /* Otherwise, keep evaluating */
        /* It's like peeling an onion layer by layer */
      }
      
      /* ğŸš€ ===== INITIALIZATION ON LOAD ===== */
      
      window.onload = () => {
        /* ğŸ¬ WHEN THE PAGE IS READY: Build the spreadsheet */
        
        const container = document.getElementById("container");
        /* ğŸ“¦ GET THE CONTAINER: Where we'll build everything */
        
        const createLabel = (name) => {
          const label = document.createElement("div");
          /* ğŸ·ï¸ CREATE LABEL: A div for each letter/number */
          
          label.className = "label";
          /* ğŸ¨ ADD CLASS: For CSS styling */
          
          label.textContent = name;
          /* ğŸ“ INSERT TEXT: The letter or the number */
          
          container.appendChild(label);
          /* ğŸ“ ATTACH TO CONTAINER: Add to the DOM */
        }
        
        const letters = charRange("A", "J");
        /* ğŸ”¤ GENERATE LETTERS: ["A", "B", ..., "J"] */
        
        letters.forEach(createLabel);
        /* ğŸ”„ CREATE COLUMN LABELS: One for each letter */
        
        range(1, 99).forEach(number => {
          /* ğŸ”¢ FOR EACH ROW (1-99): */
          
          createLabel(number);
          /* ğŸ·ï¸ CREATE ROW LABEL: The number on the left */
          
          letters.forEach(letter => {
            /* ğŸ”¤ FOR EACH COLUMN: */
            
            const input = document.createElement("input");
            /* ğŸ“ CREATE INPUT CELL: Where the user types */
            
            input.type = "text";
            /* ğŸ“ TEXT TYPE: Can contain numbers or formulas */
            
            input.id = letter + number;
            /* ğŸ†” UNIQUE ID: "A1", "B2", etc. */
            
            input.ariaLabel = letter + number;
            /* â™¿ ACCESSIBILITY: Screen reader will read "A1" */
            
            input.onchange = update;
            /* ğŸ”„ CHANGE EVENT: When the user finishes typing */
            
            container.appendChild(input);
            /* ğŸ“ ADD TO DOM: The cell is ready! */
          })
        })
      }
      
      /* ğŸ”„ ===== UPDATE CELLS ===== */
      
      const update = event => {
        const element = event.target;
        /* ğŸ¯ CHANGED ELEMENT: The cell the user modified */
        
        const value = element.value.replace(/\s/g, "");
        /* ğŸ§¹ CLEAN: Remove all whitespace */
        /* /\s/g = regex for spaces, g = global */
        
        if (!value.includes(element.id) && value.startsWith('=')) {
          /* ğŸ” FORMULA CHECK: */
          /* !value.includes(element.id) = it does not reference itself (no circular!) */
          /* value.startsWith('=') = it's a formula */
          
          element.value = evalFormula(value.slice(1), Array.from(document.getElementById("container").children));
          /* ğŸ§® COMPUTE: */
          /* value.slice(1) = remove the initial = */
          /* Array.from() = convert HTMLCollection to array */
          /* .children = all children of the container (labels and inputs) */
          /* The result replaces the formula in the cell! */
        }
      }
      
      /* ğŸ¯ ===== HOW OUR EXCEL WORKS ===== */
      /* 1. The user writes "=sum(A1:A3)" in a cell */
      /* 2. update() intercepts the change */
      /* 3. evalFormula() expands A1:A3 into A1,A2,A3 */
      /* 4. It replaces each cell with its value */
      /* 5. applyFunction() finds sum() and computes it */
      /* 6. The result appears in the cell! */
      /* It's functional programming magic! ğŸ©âœ¨ */
    </script>
  </body>
</html>












<!-- ===== ITALIAN VERSION ===== -->

<!DOCTYPE html>
<!-- ğŸ¯ DICHIARAZIONE HTML5: "Benvenuti in Excel fatto in casa!" -->
<!-- Ãˆ come aprire le porte di un ufficio contabile digitale! ğŸ“Š -->

<html lang="en">
<!-- ğŸŒ CONTENITORE PRINCIPALE: Il nostro foglio di calcolo web -->
<!-- lang="en" = inglese, la lingua universale dei numeri! ğŸ’° -->

  <head>
    <!-- ğŸ§  IL CERVELLO MATEMATICO: Dove prepariamo le formule -->
    <!-- Ãˆ come il retro di una calcolatrice dove stanno i circuiti! -->
    
    <meta charset="utf-8" />
    <!-- ğŸ“ CARATTERI UNIVERSALI: UTF-8 per numeri e simboli matematici âˆ‘âˆâˆ« -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- ğŸ“± DESIGN RESPONSIVE: "Il foglio di calcolo si adatta a ogni schermo!" -->
    <!-- Ãˆ come avere un quaderno che cambia dimensione magicamente -->
    
    <title>Functional Programming Spreadsheet</title>
    <!-- ğŸ“‘ TITOLO: Un foglio di calcolo che usa programmazione funzionale! -->
    
    <style>
      /* ğŸ¨ ===== GLI STILI DEL NOSTRO EXCEL ===== */
      
      #container {
        display: grid;
        /* ğŸ¯ CSS GRID: Il layout perfetto per un foglio di calcolo! */
        
        grid-template-columns: 50px repeat(10, 200px);
        /* ğŸ“ COLONNE: Prima colonna 50px (per i numeri), poi 10 colonne da 200px */
        /* repeat(10, 200px) = ripeti "200px" per 10 volte */
        /* Ãˆ come dire: etichette strette, celle larghe per i dati */
        
        grid-template-rows: repeat(11, 30px);
        /* ğŸ“ RIGHE: 11 righe da 30px ciascuna */
        /* Prima riga per le lettere A-J, poi 10 righe per i dati */
      }
      
      .label {
        background-color: lightgray;
        /* ğŸ”˜ SFONDO GRIGIO: Per distinguere le etichette */
        
        text-align: center;
        /* âš–ï¸ TESTO CENTRATO: Lettere e numeri al centro */
        
        vertical-align: middle;
        /* ğŸ“ ALLINEAMENTO VERTICALE: Al centro verticalmente */
        
        line-height: 30px;
        /* ğŸ“ ALTEZZA LINEA: Trucco per centrare verticalmente! */
        /* line-height = altezza della riga = centra perfettamente */
      }
    </style>
  </head>
  
  <body>
    <!-- ğŸ“Š ===== IL FOGLIO DI CALCOLO PRENDE VITA! ===== -->
    
    <div id="container">
      <!-- ğŸ“¦ CONTENITORE GRIGLIA: Qui si costruirÃ  tutto dinamicamente -->
      <div></div>
      <!-- ğŸ“ DIV VUOTO: Per l'angolo in alto a sinistra (sopra i numeri di riga) -->
    </div>
    
    <script>
      /* ğŸ§® ===== IL MOTORE MATEMATICO DEL FOGLIO DI CALCOLO ===== */
      
      const infixToFunction = {
        "+": (x, y) => x + y,
        "-": (x, y) => x - y,
        "*": (x, y) => x * y,
        "/": (x, y) => x / y,
      }
      /* ğŸ”¢ DIZIONARIO OPERATORI: Mappa simboli a funzioni matematiche */
      /* Ãˆ come avere un manuale che dice: */
      /* "+" significa "somma questi due numeri" */
      /* "-" significa "sottrai il secondo dal primo" */
      /* Arrow function (x, y) => x + y Ã¨ come dire "prendi x e y, restituisci la somma" */
      
      const infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));
      /* ğŸ¯ VALUTATORE DI ESPRESSIONI: Trova pattern matematici e li calcola! */
      /* str.replace(regex, callback) = cerca il pattern e sostituiscilo */
      /* _match = l'intero match (underscore indica che non lo usiamo) */
      /* arg1, operator, arg2 = i pezzi catturati dal regex (es: "5", "+", "3") */
      /* parseFloat() = converti stringa in numero decimale */
      /* Ãˆ come un robot che trova "5+3" e lo sostituisce con "8" */
      
      const highPrecedence = str => {
        const regex = /([\d.]+)([*\/])([\d.]+)/;
        /* ğŸ“ REGEX PER MOLTIPLICAZIONE/DIVISIONE: */
        /* ([\d.]+) = uno o piÃ¹ numeri/punti decimali (primo numero) */
        /* ([*\/]) = * oppure / (operatore) */
        /* ([\d.]+) = secondo numero */
        /* Trova pattern come "5*3" o "10/2" */
        
        const str2 = infixEval(str, regex);
        /* ğŸ”„ VALUTA: Applica moltiplicazioni e divisioni */
        
        return str === str2 ? str : highPrecedence(str2);
        /* ğŸ” RICORSIONE: Se non Ã¨ cambiato nulla, finito! Altrimenti, continua */
        /* Ãˆ come dire: "continua a fare * e / finchÃ© ce ne sono" */
        /* Ricorsione = la funzione chiama se stessa */
      }
      
      /* ğŸ§® ===== FUNZIONI MATEMATICHE DI BASE ===== */
      
      const isEven = num => num % 2 === 0;
      /* ğŸ”¢ Ãˆ PARI?: num % 2 = resto della divisione per 2 */
      /* Se il resto Ã¨ 0, il numero Ã¨ pari! */
      /* 4 % 2 = 0 (pari), 5 % 2 = 1 (dispari) */
      
      const sum = nums => nums.reduce((acc, el) => acc + el, 0);
      /* â• SOMMA: reduce() accumula tutti i valori */
      /* acc = accumulatore (parte da 0) */
      /* el = elemento corrente */
      /* Ãˆ come avere una calcolatrice che preme + per ogni numero */
      
      const average = nums => sum(nums) / nums.length;
      /* ğŸ“Š MEDIA: Somma tutti e dividi per quanti sono */
      /* Ãˆ la classica media aritmetica che usiamo a scuola! */
      
      const median = nums => {
        const sorted = nums.slice().sort((a, b) => a - b);
        /* ğŸ”„ COPIA E ORDINA: slice() crea una copia, sort() ordina */
        /* (a, b) => a - b ordina in modo crescente */
        /* Non modifichiamo l'array originale! */
        
        const length = sorted.length;
        const middle = length / 2 - 1;
        /* ğŸ“ TROVA IL CENTRO: -1 perchÃ© gli array partono da 0 */
        
        return isEven(length)
          ? average([sorted[middle], sorted[middle + 1]])
          : sorted[Math.ceil(middle)];
        /* ğŸ¯ MEDIANA: */
        /* Se pari: media dei due centrali */
        /* Se dispari: quello al centro */
        /* Math.ceil() = arrotonda per eccesso */
      }
      
      /* ğŸ“š ===== DIZIONARIO DELLE FUNZIONI DEL FOGLIO DI CALCOLO ===== */
      
      const spreadsheetFunctions = {
        "" : (nums) => nums,
        /* ğŸ”„ FUNZIONE VUOTA: Restituisce i numeri cosÃ¬ come sono */
        
        sum,
        /* â• SOMMA: Usa la funzione definita sopra */
        /* Shorthand per sum: sum (invece di sum: sum) */
        
        average,
        /* ğŸ“Š MEDIA: Media aritmetica */
        
        median,
        /* ğŸ“ˆ MEDIANA: Valore centrale */
        
        even: nums => nums.filter(isEven),
        /* ğŸ”¢ SOLO PARI: filter() tiene solo quelli che passano il test */
        
        someeven: nums => nums.some(isEven),
        /* â“ ALMENO UN PARI?: some() = true se almeno uno Ã¨ pari */
        
        everyeven: nums => nums.every(isEven),
        /* âœ… TUTTI PARI?: every() = true solo se TUTTI sono pari */
        
        firsttwo: nums => nums.slice(0, 2),
        /* âœŒï¸ PRIMI DUE: slice(0, 2) = dall'indice 0 al 2 (escluso) */
        
        lasttwo: nums => nums.slice(-2),
        /* ğŸ”š ULTIMI DUE: slice(-2) = gli ultimi 2 elementi */
        /* Indici negativi partono dalla fine! */
        
        has2: nums => nums.includes(2),
        /* ğŸ” CONTIENE 2?: includes() cerca un valore specifico */
        
        increment: nums => nums.map(num => num + 1),
        /* â•1ï¸âƒ£ INCREMENTA: map() trasforma ogni elemento */
        /* Aggiunge 1 a ogni numero */
        
        random: ([x, y]) => Math.floor(Math.random() * y + x),
        /* ğŸ² NUMERO CASUALE: Tra x e y */
        /* [x, y] = destructuring, prende i primi due elementi */
        /* Math.random() = numero tra 0 e 1 */
        /* Math.floor() = arrotonda per difetto */
        
        range: nums => range(...nums),
        /* ğŸ”¢ SEQUENZA: Crea un range di numeri */
        /* ...nums = spread operator, "spacchetta" l'array */
        
        nodupes: nums => [...new Set(nums).values()]
        /* ğŸš« NO DUPLICATI: Set rimuove automaticamente i duplicati! */
        /* [...] = spread per tornare ad array */
        /* Ãˆ come passare i numeri in un setaccio che tiene solo uno di ogni tipo */
      }
      
      /* ğŸ¯ ===== APPLICATORE DI FUNZIONI ===== */
      
      const applyFunction = str => {
        const noHigh = highPrecedence(str);
        /* ğŸ¥‡ PRIMA LE PRIORITÃ€: Risolvi * e / prima di + e - */
        
        const infix = /([\d.]+)([+-])([\d.]+)/;
        /* ğŸ“ REGEX ADDIZIONE/SOTTRAZIONE: Pattern per + e - */
        
        const str2 = infixEval(noHigh, infix);
        /* ğŸ”„ VALUTA: Ora risolvi + e - */
        
        const functionCall = /([a-z0-9]*)\(([0-9., ]*)\)(?!.*\()/i;
        /* ğŸ” REGEX CHIAMATA FUNZIONE: */
        /* ([a-z0-9]*) = nome funzione (lettere/numeri) */
        /* \( = parentesi aperta letterale */
        /* ([0-9., ]*) = argomenti (numeri, virgole, spazi) */
        /* \) = parentesi chiusa */
        /* (?!.*\() = negative lookahead: non deve avere altre ( dopo */
        /* i alla fine = case insensitive */
        /* Trova l'ultima funzione annidata da valutare */
        
        const toNumberList = args => args.split(",").map(parseFloat);
        /* ğŸ”¢ CONVERTI IN NUMERI: "1,2,3" diventa [1, 2, 3] */
        /* split(",") = dividi sulla virgola */
        /* map(parseFloat) = converti ogni pezzo in numero */
        
        const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));
        /* ğŸ¯ APPLICA FUNZIONE: */
        /* toLowerCase() = sum, SUM, Sum sono tutti uguali */
        /* Cerca la funzione nel dizionario e la esegue */
        
        return str2.replace(functionCall, (match, fn, args) => 
          spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match
        );
        /* ğŸ”„ SOSTITUISCI: Se la funzione esiste, calcola; altrimenti lascia com'Ã¨ */
        /* hasOwnProperty() = controlla se la proprietÃ  esiste */
        /* ? : = operatore ternario (if inline) */
      }
      
      /* ğŸ”¢ ===== GENERATORI DI RANGE ===== */
      
      const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);
      /* ğŸ”¢ CREA SEQUENZA NUMERICA: Da start a end (inclusi) */
      /* Array(n) = crea array di n elementi */
      /* fill(start) = riempi tutto con start */
      /* map((el, i) => el + i) = trasforma ogni elemento in start + posizione */
      /* range(5, 8) = [5, 6, 7, 8] */
      /* Ãˆ come contare sulle dita da start a end! */
      
      const charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));
      /* ğŸ”¤ CREA SEQUENZA DI LETTERE: Da start a end */
      /* charCodeAt(0) = codice ASCII della prima lettera */
      /* String.fromCharCode() = da codice ASCII a lettera */
      /* charRange("A", "D") = ["A", "B", "C", "D"] */
      /* Ãˆ come recitare l'alfabeto da una lettera all'altra! */
      
      /* ğŸ§® ===== IL CUORE: VALUTATORE DI FORMULE ===== */
      
      const evalFormula = (x, cells) => {
        const idToText = id => cells.find(cell => cell.id === id).value;
        /* ğŸ” TROVA VALORE CELLA: Cerca la cella con quell'ID e prendi il valore */
        /* find() = trova il primo elemento che soddisfa la condizione */
        
        const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;
        /* ğŸ“ REGEX PER RANGE: A1:B3 */
        /* ([A-J]) = prima lettera (A-J) */
        /* ([1-9][0-9]?) = numero 1-99 (? = opzionale) */
        /* : = due punti letterali */
        /* Stessa cosa per la seconda cella */
        /* gi = global (tutti i match) + case insensitive */
        
        const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));
        /* ğŸ”¢ NUMERI DA STRINGA: "1" e "3" diventano [1, 2, 3] */
        
        const elemValue = num => character => idToText(character + num);
        /* ğŸ¯ VALORE ELEMENTO: Funzione curry! */
        /* Prima prendi il numero, poi la lettera, poi trova il valore */
        /* elemValue(1)("A") = valore della cella A1 */
        /* Currying = funzione che restituisce funzione */
        
        const addCharacters = character1 => character2 => num => 
          charRange(character1, character2).map(elemValue(num));
        /* ğŸ”¤ AGGIUNGI CARATTERI: Triple curry! */
        /* addCharacters("A")("C")(1) = valori di A1, B1, C1 */
        /* Ãˆ come una catena di montaggio di funzioni */
        
        const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => 
          rangeFromString(num1, num2).map(addCharacters(char1)(char2))
        );
        /* ğŸ”„ ESPANDI RANGE: A1:B2 diventa A1,B1,A2,B2 */
        /* Trasforma i range in liste di celle */
        
        const cellRegex = /[A-J][1-9][0-9]?/gi;
        /* ğŸ“ REGEX SINGOLA CELLA: A1, B2, ecc. */
        
        const cellExpanded = rangeExpanded.replace(cellRegex, match => 
          idToText(match.toUpperCase())
        );
        /* ğŸ”„ SOSTITUISCI CELLE: A1 diventa il suo valore */
        
        const functionExpanded = applyFunction(cellExpanded);
        /* ğŸ¯ APPLICA FUNZIONI: Calcola sum(), average(), ecc. */
        
        return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);
        /* ğŸ” RICORSIONE: Se non Ã¨ cambiato nulla, finito! */
        /* Altrimenti, continua a valutare */
        /* Ãˆ come sbucciare una cipolla, strato dopo strato */
      }
      
      /* ğŸš€ ===== INIZIALIZZAZIONE AL CARICAMENTO ===== */
      
      window.onload = () => {
        /* ğŸ¬ QUANDO LA PAGINA Ãˆ PRONTA: Costruisci il foglio di calcolo */
        
        const container = document.getElementById("container");
        /* ğŸ“¦ PRENDI IL CONTENITORE: Dove costruiremo tutto */
        
        const createLabel = (name) => {
          const label = document.createElement("div");
          /* ğŸ·ï¸ CREA ETICHETTA: Un div per ogni lettera/numero */
          
          label.className = "label";
          /* ğŸ¨ AGGIUNGI CLASSE: Per lo stile CSS */
          
          label.textContent = name;
          /* ğŸ“ INSERISCI TESTO: La lettera o il numero */
          
          container.appendChild(label);
          /* ğŸ“ ATTACCA AL CONTENITORE: Aggiungi al DOM */
        }
        
        const letters = charRange("A", "J");
        /* ğŸ”¤ GENERA LETTERE: ["A", "B", ..., "J"] */
        
        letters.forEach(createLabel);
        /* ğŸ”„ CREA ETICHETTE COLONNE: Una per ogni lettera */
        
        range(1, 99).forEach(number => {
          /* ğŸ”¢ PER OGNI RIGA (1-99): */
          
          createLabel(number);
          /* ğŸ·ï¸ CREA ETICHETTA RIGA: Il numero sulla sinistra */
          
          letters.forEach(letter => {
            /* ğŸ”¤ PER OGNI COLONNA: */
            
            const input = document.createElement("input");
            /* ğŸ“ CREA CELLA INPUT: Dove l'utente scrive */
            
            input.type = "text";
            /* ğŸ“ TIPO TESTO: PuÃ² contenere numeri o formule */
            
            input.id = letter + number;
            /* ğŸ†” ID UNIVOCO: "A1", "B2", ecc. */
            
            input.ariaLabel = letter + number;
            /* â™¿ ACCESSIBILITÃ€: Screen reader legge "A1" */
            
            input.onchange = update;
            /* ğŸ”„ EVENTO CHANGE: Quando l'utente finisce di scrivere */
            
            container.appendChild(input);
            /* ğŸ“ AGGIUNGI AL DOM: La cella Ã¨ pronta! */
          })
        })
      }
      
      /* ğŸ”„ ===== AGGIORNAMENTO CELLE ===== */
      
      const update = event => {
        const element = event.target;
        /* ğŸ¯ ELEMENTO CAMBIATO: La cella che l'utente ha modificato */
        
        const value = element.value.replace(/\s/g, "");
        /* ğŸ§¹ PULISCI: Rimuovi tutti gli spazi */
        /* /\s/g = regex per spazi, g = tutti */
        
        if (!value.includes(element.id) && value.startsWith('=')) {
          /* ğŸ” CONTROLLO FORMULA: */
          /* !value.includes(element.id) = non riferisce a se stessa (no circolare!) */
          /* value.startsWith('=') = Ã¨ una formula */
          
          element.value = evalFormula(value.slice(1), Array.from(document.getElementById("container").children));
          /* ğŸ§® CALCOLA: */
          /* value.slice(1) = rimuovi il = iniziale */
          /* Array.from() = converti HTMLCollection in array */
          /* .children = tutti i figli del container (etichette e input) */
          /* Il risultato sostituisce la formula nella cella! */
        }
      }
      
      /* ğŸ¯ ===== COME FUNZIONA IL NOSTRO EXCEL ===== */
      /* 1. L'utente scrive "=sum(A1:A3)" in una cella */
      /* 2. update() intercetta il cambiamento */
      /* 3. evalFormula() espande A1:A3 in A1,A2,A3 */
      /* 4. Sostituisce ogni cella col suo valore */
      /* 5. applyFunction() trova sum() e la calcola */
      /* 6. Il risultato appare nella cella! */
      /* Ãˆ magia della programmazione funzionale! ğŸ©âœ¨ */
    </script>
  </body>
</html>
