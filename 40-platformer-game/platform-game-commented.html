<!-- ===== ENGLISH VERSION ===== -->

<!DOCTYPE html>
<!-- üéÆ HTML5 DECLARATION: "Welcome to our 2D Platformer Game!" -->
<!-- It's like placing the foundation for our digital playground! üèóÔ∏è -->

<html lang="en">
<!-- üåç MAIN CONTAINER: The entire game universe -->
<!-- lang="en" = English language, universal for coding experiences -->

  <head>
    <!-- üß† THE COMMAND CENTER: Where we set up the game environment -->
    <!-- Like the control room of an arcade machine! üïπÔ∏è -->
    
    <meta charset="UTF-8" />
    <!-- üìù CHARACTER ENCODING: Supports all text symbols needed for our game -->
    <!-- UTF-8 ensures everything from game text to code comments displays correctly -->
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- üîÑ BROWSER COMPATIBILITY: Ensures modern IE rendering -->
    <!-- Tells Internet Explorer to use its most modern rendering engine -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- üì± RESPONSIVE SETUP: "This game adapts to any screen!" -->
    <!-- Makes our game properly sized on all devices from phones to desktops -->
    
    <title>Learn Intermediate OOP by Building a Platformer Game</title>
    <!-- üìë TAB TITLE: Educational purpose clearly defined -->
    <!-- OOP = Object-Oriented Programming, the foundation of modern game development -->
    
    <style>
      /* üé® ===== CSS STYLES: The Visual Game World ===== */
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        /* üßπ CLEAN SLATE: Reset all browser default spacing */
        /* Ensures our game looks consistent across all browsers */
        /* Like leveling the ground before building our game world */
      }
      
      :root {
        --main-bg-color: #0a0a23;
        --section-bg-color: #ffffff;
        --golden-yellow: #feac32;
        /* üé® COLOR VARIABLES: Central palette definition */
        /* Using CSS variables makes theme changes easy and consistent */
        /* Like defining the main colors for our game world */
      }
      
      body {
        background-color: var(--main-bg-color);
        /* üåå DEEP BLUE BACKGROUND: Creates an immersive atmosphere */
        /* Dark backgrounds reduce eye strain during gameplay */
      }
      
      .start-screen {
        background-color: var(--section-bg-color);
        width: 100%;
        position: absolute;
        top: 50%;
        left: 50%;
        margin-right: -50%;
        transform: translate(-50%, -50%);
        /* ‚öñÔ∏è PERFECT CENTERING: The transform trick centers the element precisely */
        /* Horizontally AND vertically centered regardless of content size */
        
        border-radius: 30px;
        /* üîÑ ROUNDED CORNERS: Soften the visual appearance */
        /* Creates a more modern, friendly UI for players */
        
        padding: 20px;
        padding-bottom: 5px;
        /* üìè INTERNAL SPACING: Breathing room for content */
        /* Different top/bottom padding creates visual balance */
      }
      
      .main-title {
        text-align: center;
        /* ‚öñÔ∏è CENTERED TITLE: Focal point of the start screen */
        /* First thing players see - creates hierarchy and focus */
      }
      
      .instructions {
        text-align: center;
        font-size: 1.2rem;
        margin: 15px;
        line-height: 2rem;
        /* üìù CLEAR INSTRUCTIONS: Readability optimized text */
        /* font-size: 1.2rem = 20% larger than default text */
        /* line-height: 2rem = double-spaced for easier reading */
        /* Ensures players understand how to play before starting */
      }
      
      .btn {
        cursor: pointer;
        /* üëÜ HAND CURSOR: Visual cue that element is clickable */
        
        width: 100px;
        margin: 10px;
        /* üìè BUTTON DIMENSIONS: Comfortable click target size */
        /* 100px wide with 10px margin creates good spacing */
        
        color: #0a0a23;
        font-size: 18px;
        /* üî§ TEXT STYLE: Dark text on light button for readability */
        /* 18px font ensures text is easily readable on all devices */
        
        background-color: var(--golden-yellow);
        background-image: linear-gradient(#fecc4c, #ffac33);
        /* üåÖ GRADIENT BACKGROUND: Creates 3D button effect */
        /* Top lighter, bottom darker creates illusion of light from above */
        
        border-color: var(--golden-yellow);
        border-width: 3px;
        /* üî≤ BORDER STYLE: Thick border matches background */
        /* 3px width makes the border clearly visible */
      }
      
      .btn:hover {
        background-image: linear-gradient(#ffcc4c, #f89808);
        /* ‚ú® HOVER EFFECT: Button brightens when mouse hovers */
        /* Visual feedback before clicking improves user experience */
        /* Slightly different gradient creates "activated" appearance */
      }
      
      .btn-container {
        display: flex;
        align-items: center;
        justify-content: center;
        /* üì¶ FLEXBOX CENTERING: Perfect horizontal alignment */
        /* Modern approach to centering with CSS */
        /* Ensures button is perfectly centered regardless of screen size */
      }
      
      .checkpoint-screen {
        position: absolute;
        left: 0;
        right: 0;
        margin-left: auto;
        margin-right: auto;
        /* ‚öñÔ∏è HORIZONTAL CENTERING: Old-school technique */
        /* Setting both left/right to 0 with auto margins centers the element */
        
        width: 100%;
        text-align: center;
        background-color: var(--section-bg-color);
        border-radius: 20px;
        padding: 10px;
        /* üìã POPUP STYLING: Clean, readable notification */
        /* White background with rounded corners for a modern look */
        
        display: none;
        /* üôà INITIALLY HIDDEN: Only appears at checkpoints */
        /* JavaScript will change this to "block" when needed */
      }
      
      #canvas {
        display: none;
        /* üôà HIDDEN CANVAS: Revealed when game starts */
        /* Initially hidden to show start screen instead */
      }
      
      @media (min-width: 768px) {
        /* üì± RESPONSIVE BREAKPOINT: Tablet and larger screens */
        /* 768px is standard tablet portrait width */
        
        .start-screen {
          width: 60%;
          max-width: 700px;
          /* üìè DESKTOP SIZING: Narrower, centered panel */
          /* Prevents the start screen from stretching too wide on large screens */
          /* 60% width with 700px maximum creates ideal reading width */
        }
      
        .checkpoint-screen {
          max-width: 300px;
          /* üìè NOTIFICATION SIZING: Compact on larger screens */
          /* 300px is wide enough for content but not intrusive */
        }
      }
    </style>
  </head>
  <body>
    <!-- üéÆ ===== THE GAME INTERFACE: Player's View into the Game World ===== -->
    
    <div class="start-screen">
      <!-- üé¨ START SCREEN: The initial game menu -->
      <!-- Like the title screen of classic arcade games! -->
      
      <h1 class="main-title">freeCodeCamp Code Warrior</h1>
      <!-- üìë GAME TITLE: Establishes theme and branding -->
      <!-- "Code Warrior" suggests a coding-themed adventure -->
      
      <p class="instructions">
        Help the main player navigate to the yellow checkpoints.
      </p>
      <!-- üìù GAME OBJECTIVE: Clear description of goals -->
      <!-- Tells player exactly what they need to accomplish -->
      
      <p class="instructions">
        Use the keyboard arrows to move the player around.
      </p>
      <!-- üéÆ CONTROL SCHEME 1: Movement controls explained -->
      <!-- Arrow keys are intuitive for 2D movement -->
      
      <p class="instructions">You can also use the spacebar to jump.</p>
      <!-- üéÆ CONTROL SCHEME 2: Jump mechanic explained -->
      <!-- Spacebar is the standard jump button in most platformers -->

      <div class="btn-container">
        <!-- üì¶ BUTTON WRAPPER: Centers the start button -->
        
        <button class="btn" id="start-btn">Start Game</button>
        <!-- üéØ START BUTTON: Initiates the game -->
        <!-- Critical interactive element with unique ID for JavaScript -->
      </div>
    </div>

    <div class="checkpoint-screen">
      <!-- üèÜ CHECKPOINT NOTIFICATION: Appears when reaching goals -->
      <!-- Provides positive feedback for player achievements -->
      
      <h2>Congrats!</h2>
      <!-- üéâ CELEBRATION HEADER: Positive reinforcement -->
      <!-- Congratulatory message creates satisfaction -->
      
      <p>You reached the last checkpoint.</p>
      <!-- üìù ACHIEVEMENT MESSAGE: Clarifies what happened -->
      <!-- Will be updated via JavaScript for different checkpoints -->
    </div>

    <canvas id="canvas"></canvas>
    <!-- üñºÔ∏è CANVAS ELEMENT: The actual game rendering surface -->
    <!-- HTML5 Canvas is like a blank drawing board for our JavaScript -->
    <!-- All game visuals will be drawn here programmatically -->

    <script>
      /* üéÆ ===== JAVASCRIPT: The Game Engine! ===== */
      
      /* üîç ===== DOM ELEMENT SELECTION: Connecting JS to HTML ===== */
      
      const startBtn = document.getElementById("start-btn");
      /* üîò START BUTTON REFERENCE: Direct access by ID */
      /* getElementById is the fastest selector method - perfect for critical elements */
      /* Like grabbing the ignition switch for our game engine */
      
      const canvas = document.getElementById("canvas");
      /* üñºÔ∏è CANVAS REFERENCE: Our drawing surface */
      /* This element will become our entire game world */
      /* Like getting a blank canvas before painting a masterpiece */
      
      const startScreen = document.querySelector(".start-screen");
      /* üé¨ START SCREEN REFERENCE: Using class selector */
      /* querySelector finds the first matching element with this class */
      /* We'll hide this when the game starts */
      
      const checkpointScreen = document.querySelector(".checkpoint-screen");
      /* üèÜ CHECKPOINT SCREEN REFERENCE: For victory messages */
      /* This popup will appear when players reach checkpoints */
      
      const checkpointMessage = document.querySelector(".checkpoint-screen > p");
      /* üìù MESSAGE REFERENCE: Direct child selector */
      /* The ">" symbol selects ONLY direct children (not grandchildren) */
      /* We'll update this text when different checkpoints are reached */
      
      /* üé® ===== CANVAS SETUP: Preparing Our Drawing Surface ===== */
      
      const ctx = canvas.getContext("2d");
      /* üñåÔ∏è DRAWING CONTEXT: The actual drawing API */
      /* getContext("2d") gives us access to the Canvas drawing tools */
      /* Like getting a paintbrush to use on our canvas */
      /* This is what we'll use to draw shapes, colors, and the game world */
      
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      /* üìè CANVAS DIMENSIONS: Full screen size */
      /* Setting width/height in JS overrides any CSS sizing */
      /* This creates a 1:1 pixel ratio for crisp rendering */
      /* Without this, canvas would default to 300x150px and look blurry when stretched */
      
      /* üåç ===== GAME PHYSICS CONSTANTS: The Rules of Our World ===== */
      
      const gravity = 0.5;
      /* ‚¨áÔ∏è GRAVITY CONSTANT: Force pulling player down */
      /* This isn't realistic Earth gravity (9.8 m/s¬≤) but a value that feels good */
      /* Each frame adds 0.5 to vertical velocity ‚Üí accelerating fall */
      /* Higher values = faster falling, lower values = floatier jumps */
      
      let isCheckpointCollisionDetectionActive = true;
      /* üö¶ COLLISION FLAG: Controls checkpoint detection */
      /* This boolean acts like an on/off switch for checkpoint interactions */
      /* When false, prevents the same checkpoint from triggering multiple times */
      /* Critical for avoiding the checkpoint triggering 60 times per second! */
      
      /* üìè ===== SCALING FUNCTION: Responsive Game Elements ===== */
      
      const proportionalSize = (size) => {
        return innerHeight < 500 ? Math.ceil((size / 500) * innerHeight) : size;
        /* üì± ADAPTIVE SCALING: Elements resize for small screens */
        /* If screen height < 500px: scales everything proportionally */
        /* Formula: (size √∑ reference height) √ó actual height */
        /* Math.ceil() rounds up to prevent zero-size elements */
        /* On taller screens: uses original size values */
        /* Like having a responsive blueprint for our game world */
      }
      
      /* üßç ===== PLAYER CLASS: The Main Character ===== */
      
      class Player {
        /* üìò CLASS DEFINITION: Blueprint for creating players */
        /* Classes are templates that define properties and behaviors */
        /* Like defining what makes a "player" in our game universe */
        
        constructor() {
          /* üèóÔ∏è CONSTRUCTOR METHOD: Runs when creating new Player */
          /* This method initializes all player properties */
          /* Like building the player character from scratch */
          
          this.position = {
            x: proportionalSize(10),
            y: proportionalSize(400),
          };
          /* üìç STARTING POSITION: Where player begins */
          /* Coordinates from top-left corner of screen */
          /* Using proportionalSize ensures this works on all screen sizes */
          
          this.velocity = {
            x: 0, /* Horizontal speed (pixels per frame) */
            y: 0, /* Vertical speed (pixels per frame) */
          };
          /* üèéÔ∏è VELOCITY VECTOR: Speed and direction */
          /* Separate x/y components allow independent horizontal/vertical movement */
          /* 0 means standing still in each direction */
          
          this.width = proportionalSize(40);
          this.height = proportionalSize(40);
          /* üìè PLAYER DIMENSIONS: Size of character */
          /* 40x40px creates a square player (responsive on small screens) */
          /* Size affects both visuals and collision detection */
        }
        
        draw() {
          /* üé® DRAWING METHOD: Renders player on screen */
          /* Called every frame to show the player */
          
          ctx.fillStyle = "#99c9ff";
          /* üé® PLAYER COLOR: Light blue */
          /* Sets the "paint color" before drawing */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DRAW RECTANGLE: Creates the player shape */
          /* fillRect(x, y, width, height) draws a filled rectangle */
          /* This simple square represents our character */
          /* In professional games, this would be replaced with sprite images */
        }
        
        update() {
          /* üîÑ UPDATE METHOD: Game physics and logic */
          /* Called every frame (60 times per second) */
          /* Heart of the player's behavior in the game */
          
          this.draw();
          /* üé® RENDER FIRST: Ensures player is visible */
          /* Always draw before moving to prevent visual glitches */
          
          this.position.x += this.velocity.x;
          this.position.y += this.velocity.y;
          /* üö∂ MOVEMENT PHYSICS: Position changes based on velocity */
          /* This is the core movement equation: position += velocity */
          /* The direction and speed of movement depend on velocity values */
          
          if (this.position.y + this.height + this.velocity.y <= canvas.height) {
            /* üå°Ô∏è GRAVITY CHECK: Is player still in the air? */
            /* Condition checks if player hasn't reached bottom of screen */
            /* Bottom edge position = y position + height */
            
            if (this.position.y < 0) {
              /* üõë TOP BOUNDARY CHECK: Is player trying to leave screen? */
              /* y < 0 means player is trying to jump above the canvas */
              
              this.position.y = 0;
              this.velocity.y = gravity;
              /* üîÑ CEILING COLLISION: Bounce player down */
              /* Prevents going above screen and starts falling */
            }
            
            this.velocity.y += gravity;
            /* ‚¨áÔ∏è APPLY GRAVITY: Increases falling speed */
            /* This creates acceleration - falling gets faster over time */
            /* The foundation of realistic jumping physics! */
          } else {
            /* üõë FLOOR COLLISION: Player reached bottom */
            
            this.velocity.y = 0;
            /* üõë STOP FALLING: Sets vertical velocity to zero */
            /* Prevents player from falling through the floor */
          }
      
          if (this.position.x < this.width) {
            /* üõë LEFT BOUNDARY CHECK: Prevent leaving screen left */
            
            this.position.x = this.width;
            /* üîô PUSH BACK: Sets position to edge of screen */
            /* Creates an invisible wall at the left screen edge */
          }
      
          if (this.position.x >= canvas.width - this.width * 2) {
            /* üõë RIGHT BOUNDARY CHECK: Prevent leaving screen right */
            
            this.position.x = canvas.width - this.width * 2;
            /* üîô PUSH BACK: Sets position to edge of screen */
            /* The multiplication creates a better visual boundary */
          }
        }
      }
      
      /* üß± ===== PLATFORM CLASS: The Solid Ground ===== */
      
      class Platform {
        /* üìò CLASS DEFINITION: Blueprint for platforms */
        /* Each platform is a surface the player can stand on */
        
        constructor(x, y) {
          /* üèóÔ∏è CONSTRUCTOR WITH PARAMETERS: Customizable platforms */
          /* Takes x,y coordinates to place platforms anywhere */
          /* Like placing building blocks in our world */
          
          this.position = {
            x, /* Shorthand for x: x */
            y, /* Shorthand for y: y */
          };
          /* üìç PLATFORM POSITION: Custom placement */
          /* Modern JS allows shorthand when property name = variable name */
          /* This creates the platform at the exact coordinates we specify */
          
          this.width = 200;
          this.height = proportionalSize(40);
          /* üìè PLATFORM SIZE: Width and height */
          /* 200px wide creates platforms player can run across */
          /* Height scales with screen size for consistency */
        }
        
        draw() {
          /* üé® DRAWING METHOD: Renders platform on screen */
          
          ctx.fillStyle = "#acd157";
          /* üé® PLATFORM COLOR: Light green */
          /* A grass-like color distinguishes platforms from player */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DRAW RECTANGLE: Creates the platform shape */
          /* Simple rectangle represents each platform */
        }
      }
      
      /* üö© ===== CHECKPOINT CLASS: The Goal Markers ===== */
      
      class CheckPoint {
        /* üìò CLASS DEFINITION: Blueprint for goal markers */
        /* These are the objectives player must reach */
        
        constructor(x, y, z) {
          /* üèóÔ∏è CONSTRUCTOR WITH PARAMETERS: Customizable checkpoints */
          /* x,y = position, z = checkpoint number/sequence */
          
          this.position = {
            x,
            y,
          };
          /* üìç CHECKPOINT POSITION: Custom placement */
          /* Uses same shorthand syntax as Platform */
          
          this.width = proportionalSize(40);
          this.height = proportionalSize(70);
          /* üìè CHECKPOINT SIZE: Tall and narrow */
          /* Taller than player to be easily visible */
          
          this.claimed = false;
          /* üö© CLAIMED FLAG: Tracks checkpoint status */
          /* false = not reached yet, true = already collected */
          /* Like a virtual "I was here" flag the player plants */
        };
      
        draw() {
          /* üé® DRAWING METHOD: Renders checkpoint on screen */
          
          ctx.fillStyle = "#f1be32";
          /* üé® CHECKPOINT COLOR: Golden yellow */
          /* Bright color makes checkpoints stand out as objectives */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DRAW RECTANGLE: Creates the checkpoint shape */
          /* Vertical rectangle resembles a finish flag */
        }
        
        claim() {
          /* üèÅ CLAIM METHOD: "Collects" the checkpoint */
          /* Called when player reaches this checkpoint */
          
          this.width = 0;
          this.height = 0;
          /* üôà MAKE INVISIBLE: Zero dimensions hide it */
          /* Rather than removing from array, we make it invisible */
          
          this.position.y = Infinity;
          /* üå† SEND AWAY: Moves far off-screen */
          /* Infinity ensures it can never be collided with again */
          /* This is safer than modifying the array during iteration */
          
          this.claimed = true;
          /* üö© MARK AS CLAIMED: Updates status flag */
          /* This helps track progress and checkpoint sequence */
          /* Used for conditional logic in collision detection */
        }
      };
      
      /* üè≠ ===== GAME OBJECT CREATION: Building the World ===== */
      
      const player = new Player();
      /* üßç CREATE PLAYER: Instance of Player class */
      /* new Player() calls the constructor and creates a functional object */
      /* Like hitting the "print" button on our player blueprint */
      
      const platformPositions = [
        { x: 500, y: proportionalSize(450) },
        { x: 700, y: proportionalSize(400) },
        { x: 850, y: proportionalSize(350) },
        { x: 900, y: proportionalSize(350) },
        { x: 1050, y: proportionalSize(150) },
        { x: 2500, y: proportionalSize(450) },  /* Big gap ‚Üí challenge! */
        { x: 2900, y: proportionalSize(400) },
        { x: 3150, y: proportionalSize(350) },
        { x: 3900, y: proportionalSize(450) },  /* Other gap */
        { x: 4200, y: proportionalSize(400) },
        { x: 4400, y: proportionalSize(200) },
        { x: 4700, y: proportionalSize(150) },
      ];
      /* üó∫Ô∏è LEVEL DESIGN: Platform coordinates array */
      /* Each object holds x,y position for one platform */
      /* This is our "level blueprint" - separating data from logic */
      /* The comments note where challenging gaps occur in the level */
      
      const platforms = platformPositions.map(
        (platform) => new Platform(platform.x, platform.y)
      );
      /* üè≠ PLATFORM CREATION: Transforms data into objects */
      /* map() converts each position into a functional Platform */
      /* This is like a factory assembly line: data in ‚Üí objects out */
      /* Arrow function with implicit return creates each Platform */
      
      const checkpointPositions = [
        { x: 1170, y: proportionalSize(80), z: 1 },
        { x: 2900, y: proportionalSize(330), z: 2 },
        { x: 4800, y: proportionalSize(80), z: 3 },
      ];
      /* üö© CHECKPOINT LOCATIONS: Objective coordinates */
      /* Three checkpoints are placed at strategic points in the level */
      /* z value tracks the checkpoint sequence number */
      
      const checkpoints = checkpointPositions.map(
        (checkpoint) => new CheckPoint(checkpoint.x, checkpoint.y, checkpoint.z)
      );
      /* üè≠ CHECKPOINT CREATION: Transforms data into objects */
      /* Same mapping pattern as platforms, creating CheckPoint objects */
      
      /* üîÑ ===== GAME LOOP: The Animation Engine ===== */
      
      const animate = () => {
        /* üé¨ MAIN GAME LOOP: Function runs every frame */
        /* This is the heartbeat of our game - everything happens here */
        
        requestAnimationFrame(animate);
        /* üîÑ LOOP CREATION: Browser animation API */
        /* Asks browser to call animate() before next repaint */
        /* Creates a smooth 60fps loop optimized for performance */
        /* Self-referential - animate calls itself creating infinite loop */
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        /* üßπ CLEAR CANVAS: Wipes previous frame */
        /* Like erasing a whiteboard before drawing the next state */
        /* Without this, movements would leave trails behind them */
      
        platforms.forEach((platform) => {
          platform.draw();
        });
        /* üé® DRAW PLATFORMS: Render all platforms */
        /* forEach executes the function on each array element */
        /* Each platform's draw() method is called to render it */
      
        checkpoints.forEach(checkpoint => {
          checkpoint.draw();
        });
        /* üé® DRAW CHECKPOINTS: Render all checkpoints */
        /* Same pattern as platforms - draw each checkpoint */
      
        player.update();
        /* üîÑ UPDATE PLAYER: Physics and rendering */
        /* This calls the player's update method which:
           1. Draws the player
           2. Updates position based on velocity
           3. Applies gravity and boundary checks */
      
        /* üì∑ ===== CAMERA MOVEMENT: Scrolling The World ===== */
        
        if (keys.rightKey.pressed && player.position.x < proportionalSize(400)) {
          /* üèÉ‚Äç‚ôÇÔ∏è PLAYER MOVEMENT RIGHT: Move player when away from center */
          /* When right key pressed AND player left of center point */
          
          player.velocity.x = 5;
          /* ‚û°Ô∏è SET VELOCITY: Move player right */
          /* 5 pixels per frame creates smooth movement */
        } else if (keys.leftKey.pressed && player.position.x > proportionalSize(100)) {
          /* üèÉ‚Äç‚ôÇÔ∏è PLAYER MOVEMENT LEFT: Move player when away from left edge */
          /* When left key pressed AND player right of left boundary */
          
          player.velocity.x = -5;
          /* ‚¨ÖÔ∏è SET VELOCITY: Move player left */
          /* Negative velocity means leftward movement */
        } else {
          /* üõë CENTRAL POSITION: Player near center or edges */
          
          player.velocity.x = 0;
          /* üõë STOP HORIZONTAL MOVEMENT: Player stationary */
          /* Reset velocity to zero - player stops moving horizontally */
      
          /* üåé WORLD SCROLLING: Move environment instead of player */
          /* This creates the illusion of a moving camera following the player */
          
          if (keys.rightKey.pressed && isCheckpointCollisionDetectionActive) {
            /* ‚û°Ô∏è SCROLL RIGHT: Move world when player centered */
            /* Active only when checkpoint collision is enabled */
            
            platforms.forEach((platform) => {
              platform.position.x -= 5;
              /* ‚¨ÖÔ∏è MOVE PLATFORMS LEFT: World scrolls opposite to player direction */
              /* Creates illusion of player moving right */
            });
      
            checkpoints.forEach((checkpoint) => {
              checkpoint.position.x -= 5;
              /* ‚¨ÖÔ∏è MOVE CHECKPOINTS LEFT: Keep synchronized with platforms */
              /* Everything in world moves together for consistent scrolling */
            });
          
          } else if (keys.leftKey.pressed && isCheckpointCollisionDetectionActive) {
            /* ‚¨ÖÔ∏è SCROLL LEFT: Move world when player centered */
            
            platforms.forEach((platform) => {
              platform.position.x += 5;
              /* ‚û°Ô∏è MOVE PLATFORMS RIGHT: World scrolls opposite to player direction */
              /* Creates illusion of player moving left */
            });
      
            checkpoints.forEach((checkpoint) => {
              checkpoint.position.x += 5;
              /* ‚û°Ô∏è MOVE CHECKPOINTS RIGHT: Keep synchronized with platforms */
            });
          }
        }
      
        /* üí• ===== PLATFORM COLLISION DETECTION ===== */
        
        platforms.forEach((platform) => {
          /* üîç CHECK EACH PLATFORM: Iterate through all platforms */
          
          const collisionDetectionRules = [
            player.position.y + player.height <= platform.position.y,
            /* ‚¨áÔ∏è RULE 1: Player's bottom above platform's top */
            /* Ensures player is descending onto platform from above */
            
            player.position.y + player.height + player.velocity.y >= platform.position.y,
            /* ‚¨áÔ∏è RULE 2: Player's next position will intersect platform */
            /* Predicts collision based on current velocity */
            
            player.position.x >= platform.position.x - player.width / 2,
            /* ‚¨ÖÔ∏è RULE 3: Player not too far left of platform */
            /* Horizontal position check - left edge */
            
            player.position.x <=
              platform.position.x + platform.width - player.width / 3,
            /* ‚û°Ô∏è RULE 4: Player not too far right of platform */
            /* Horizontal position check - right edge */
          ];
      
          if (collisionDetectionRules.every((rule) => rule)) {
            /* ‚úÖ ALL RULES TRUE: Standing on platform */
            /* every() checks if ALL conditions return true */
            /* This is like a logical AND between all conditions */
            
            player.velocity.y = 0;
            /* üõë STOP FALLING: Land on platform */
            /* Zero vertical velocity prevents falling through platform */
            
            return;
            /* üö™ EXIT LOOP: Skip remaining platforms */
            /* Once we've found a collision, no need to check others */
          }
      
          /* üí• COLLISION FROM BELOW: Hitting platform from underneath */
          
          const platformDetectionRules = [
            player.position.x >= platform.position.x - player.width / 2,
            /* ‚¨ÖÔ∏è RULE 1: Horizontal overlap check (left) */
            
            player.position.x <=
              platform.position.x + platform.width - player.width / 3,
            /* ‚û°Ô∏è RULE 2: Horizontal overlap check (right) */
            
            player.position.y + player.height >= platform.position.y,
            /* ‚¨ÜÔ∏è RULE 3: Player's bottom below platform's top */
            
            player.position.y <= platform.position.y + platform.height,
            /* ‚¨áÔ∏è RULE 4: Player's top above platform's bottom */
          ];
      
          if (platformDetectionRules.every(rule => rule)) {
            /* ‚úÖ ALL RULES TRUE: Hitting platform from below */
            
            player.position.y = platform.position.y + player.height;
            /* ‚¨áÔ∏è PUSH DOWN: Move player below platform */
            /* Prevents getting stuck inside platform */
            
            player.velocity.y = gravity;
            /* ‚¨áÔ∏è START FALLING: Apply gravity */
            /* Bounces player down after hitting head */
          };
        });
      
        /* üö© ===== CHECKPOINT COLLISION DETECTION ===== */
        
        checkpoints.forEach((checkpoint, index, checkpoints) => {
          /* üîç CHECK EACH CHECKPOINT: Iterate through all checkpoints */
          /* index = position in array, checkpoints = the full array */
          
          const checkpointDetectionRules = [
            player.position.x >= checkpoint.position.x,
            /* ‚û°Ô∏è RULE 1: Player right edge beyond checkpoint left */
            
            player.position.y >= checkpoint.position.y,
            /* ‚¨áÔ∏è RULE 2: Player below top of checkpoint */
            
            player.position.y + player.height <=
              checkpoint.position.y + checkpoint.height,
            /* ‚¨ÜÔ∏è RULE 3: Player within vertical bounds of checkpoint */
            
            isCheckpointCollisionDetectionActive,
            /* üö¶ RULE 4: Collision detection system is active */
            /* Prevents multiple activations when global switch is off */
            
            player.position.x - player.width <=
              checkpoint.position.x - checkpoint.width + player.width * 0.9,
            /* ‚¨ÖÔ∏è RULE 5: Complex horizontal alignment check */
            /* Ensures player is properly positioned relative to checkpoint */
            
            index === 0 || checkpoints[index - 1].claimed === true,
            /* üî¢ RULE 6: Checkpoint order check */
            /* Either this is the first checkpoint OR previous one was claimed */
            /* Forces sequential checkpoint collection */
          ];
      
          if (checkpointDetectionRules.every((rule) => rule)) {
            /* ‚úÖ ALL RULES TRUE: Checkpoint reached */
            
            checkpoint.claim();
            /* üèÅ CLAIM CHECKPOINT: Mark as reached */
            /* This hides the checkpoint and marks it claimed */
      
            if (index === checkpoints.length - 1) {
              /* üèÜ FINAL CHECKPOINT: Last in array */
              /* Length - 1 is the index of the last item */
              
              isCheckpointCollisionDetectionActive = false;
              /* üö´ DISABLE COLLISIONS: Game effectively ends */
              /* Prevents further checkpoint activations */
              
              showCheckpointScreen("You reached the final checkpoint!");
              /* üéâ VICTORY MESSAGE: Final achievement */
              /* Shows celebration message with custom text */
              
              movePlayer("ArrowRight", 0, false);
              /* üõë STOP PLAYER: Prevent movement after winning */
              /* Reset movement state to make player stand still */
            } else if (player.position.x >= checkpoint.position.x && player.position.x <= checkpoint.position.x + 40) {
              /* ‚úÖ REGULAR CHECKPOINT: Not the final one */
              /* Additional position check ensures proper trigger timing */
              
              showCheckpointScreen("You reached a checkpoint!");
              /* üéâ PROGRESS MESSAGE: Intermediate achievement */
            }
          };
        });
      }
      
      /* üéÆ ===== KEYBOARD STATE TRACKING ===== */
      
      const keys = {
        rightKey: {
          pressed: false
        },
        leftKey: {
          pressed: false
        }
      };
      /* üéÆ KEYBOARD STATE OBJECT: Tracks pressed keys */
      /* Nested objects: keys ‚Üí rightKey ‚Üí pressed */
      /* Using boolean flags instead of checking key state every frame */
      /* This allows for smooth, consistent movement */
      
      const movePlayer = (key, xVelocity, isPressed) => {
        /* üèÉ‚Äç‚ôÇÔ∏è PLAYER MOVEMENT FUNCTION: Processes key actions */
        /* key = which key was pressed */
        /* xVelocity = how fast to move */
        /* isPressed = key down or key up? */
        
        if (!isCheckpointCollisionDetectionActive) {
          /* üö´ GAME OVER CHECK: Block movement if game ended */
          
          player.velocity.x = 0;
          player.velocity.y = 0;
          /* üõë FREEZE PLAYER: Stop all movement */
          
          return;
          /* üö™ EXIT FUNCTION: Skip remaining code */
        }
      
        switch (key) {
          /* üîÄ KEY SWITCH: Different action for each key */
          /* Efficient way to handle multiple key options */
          
          case "ArrowLeft":
            /* ‚¨ÖÔ∏è LEFT ARROW: Move player left */
            
            keys.leftKey.pressed = isPressed;
            /* üîÑ UPDATE KEY STATE: Track if key is down */
            
            if (xVelocity === 0) {
              player.velocity.x = xVelocity;
              /* üõë ZERO VELOCITY: For key up event */
              /* When releasing key, stop moving immediately */
            }
            player.velocity.x -= xVelocity;
            /* ‚¨ÖÔ∏è APPLY VELOCITY: Move left */
            /* Subtract from x velocity to move left */
            break;
            
          case "ArrowUp":
          case " ":
          case "Spacebar":
            /* ‚¨ÜÔ∏è UP/SPACE: Jump action */
            /* Multiple cases handle different jump keys */
            /* Both arrow up and spacebar trigger jump */
            
            player.velocity.y -= 8;
            /* ‚¨ÜÔ∏è JUMP VELOCITY: Move upward */
            /* Negative y velocity means moving up */
            /* Value of 8 creates a satisfying jump height */
            break;
            
          case "ArrowRight":
            /* ‚û°Ô∏è RIGHT ARROW: Move player right */
            
            keys.rightKey.pressed = isPressed;
            /* üîÑ UPDATE KEY STATE: Track if key is down */
            
            if (xVelocity === 0) {
              player.velocity.x = xVelocity;
              /* üõë ZERO VELOCITY: For key up event */
            }
            player.velocity.x += xVelocity;
            /* ‚û°Ô∏è APPLY VELOCITY: Move right */
            /* Add to x velocity to move right */
        }
      }
      
      /* üéÆ ===== GAME MANAGEMENT FUNCTIONS ===== */
      
      const startGame = () => {
        /* üèÅ GAME STARTER: Initializes gameplay */
        
        canvas.style.display = "block";
        /* üñºÔ∏è SHOW CANVAS: Make game visible */
        /* Changes display from "none" to "block" */
        
        startScreen.style.display = "none";
        /* üôà HIDE START SCREEN: Remove menu */
        /* Once game starts, we don't need the menu */
        
        animate();
        /* üé¨ START ANIMATION: Begin game loop */
        /* This launches the core game engine */
      }
      
      const showCheckpointScreen = (msg) => {
        /* üèÜ CHECKPOINT NOTIFIER: Displays achievement message */
        /* msg = custom text for different checkpoints */
        
        checkpointScreen.style.display = "block";
        /* üìù SHOW MESSAGE: Make notification visible */
        
        checkpointMessage.textContent = msg;
        /* üìù SET TEXT: Update message content */
        /* Uses the parameter to customize the message */
        
        if (isCheckpointCollisionDetectionActive) {
          /* ‚è±Ô∏è TEMPORARY DISPLAY: Only if game still active */
          
          setTimeout(() => (checkpointScreen.style.display = "none"), 2000);
          /* ‚è±Ô∏è TIMED REMOVAL: Hide after 2 seconds */
          /* setTimeout runs the function after delay in milliseconds */
          /* Arrow function with parentheses around single statement */
        }
      };
      
      /* üñ±Ô∏è ===== EVENT LISTENERS: User Input Handling ===== */
      
      startBtn.addEventListener("click", startGame);
      /* üé¨ START BUTTON LISTENER: Begin game on click */
      /* Connects HTML button to JavaScript function */
      
      window.addEventListener("keydown", ({ key }) => {
        /* üéÆ KEY PRESS LISTENER: Detect when keys are pressed */
        /* { key } uses destructuring to extract key property from event */
        /* Much cleaner than writing (event) and then event.key */
        
        movePlayer(key, 8, true);
        /* üèÉ‚Äç‚ôÇÔ∏è HANDLE KEY PRESS: Move at speed 8, key is pressed */
        /* true = key is pressed (keydown event) */
      });
      
      window.addEventListener("keyup", ({ key }) => {
        /* üéÆ KEY RELEASE LISTENER: Detect when keys are released */
        /* Counterpart to keydown - needed for smooth controls */
        
        movePlayer(key, 0, false);
        /* üõë HANDLE KEY RELEASE: Stop movement, key is released */
        /* 0 = zero velocity (stop moving) */
        /* false = key is released (keyup event) */
      });
    </script>
  </body>
</html>

<!-- üéØ ===== PLATFORMER GAME SUMMARY ===== -->
<!-- 
üéÆ GAME ARCHITECTURE:
‚îÇ
‚îú‚îÄ‚îÄ üñ•Ô∏è HTML STRUCTURE
‚îÇ   ‚îú‚îÄ‚îÄ üìã Start screen with instructions
‚îÇ   ‚îú‚îÄ‚îÄ üèÜ Checkpoint notification popup
‚îÇ   ‚îî‚îÄ‚îÄ üñºÔ∏è Canvas game surface
‚îÇ
‚îú‚îÄ‚îÄ üé® CSS STYLING
‚îÇ   ‚îú‚îÄ‚îÄ üéÆ Game interface components
‚îÇ   ‚îú‚îÄ‚îÄ üîò Interactive button styling
‚îÇ   ‚îî‚îÄ‚îÄ üì± Responsive design for all screens
‚îÇ
‚îî‚îÄ‚îÄ üß† JAVASCRIPT GAME ENGINE
    ‚îú‚îÄ‚îÄ üì¶ Object-Oriented Programming (Classes)
    ‚îÇ   ‚îú‚îÄ‚îÄ üßç Player with physics and collision
    ‚îÇ   ‚îú‚îÄ‚îÄ üß± Platforms for navigation
    ‚îÇ   ‚îî‚îÄ‚îÄ üö© Checkpoints for objectives
    ‚îÇ
    ‚îú‚îÄ‚îÄ üéÆ Game Mechanics
    ‚îÇ   ‚îú‚îÄ‚îÄ ‚¨áÔ∏è Gravity and jumping physics
    ‚îÇ   ‚îú‚îÄ‚îÄ üì∑ Camera scrolling system
    ‚îÇ   ‚îú‚îÄ‚îÄ üí• Collision detection
    ‚îÇ   ‚îî‚îÄ‚îÄ üèÜ Progressive checkpoint system
    ‚îÇ
    ‚îî‚îÄ‚îÄ üîÑ Technical Implementation
        ‚îú‚îÄ‚îÄ üé¨ RequestAnimationFrame loop
        ‚îú‚îÄ‚îÄ üìè Proportional sizing for responsiveness
        ‚îú‚îÄ‚îÄ üéÆ Event-driven keyboard controls
        ‚îî‚îÄ‚îÄ üéØ State management for game progress

This project demonstrates core principles of game development through OOP!
From physics simulation to collision detection, it's a complete mini-game engine!
-->










<!-- ===== ITALIAN VERSION ===== -->

<!DOCTYPE html>
<!-- üéÆ DICHIARAZIONE HTML5: "Benvenuti nel nostro Gioco Platformer 2D!" -->
<!-- √à come porre le fondamenta per il nostro parco giochi digitale! üèóÔ∏è -->

<html lang="en">
<!-- üåç CONTENITORE PRINCIPALE: L'intero universo di gioco -->
<!-- lang="en" = Lingua inglese, universale per le esperienze di codifica -->

  <head>
    <!-- üß† CENTRO DI COMANDO: Dove impostiamo l'ambiente di gioco -->
    <!-- Come la sala di controllo di un cabinato arcade! üïπÔ∏è -->
    
    <meta charset="UTF-8" />
    <!-- üìù CODIFICA CARATTERI: Supporta tutti i simboli di testo necessari per il nostro gioco -->
    <!-- UTF-8 assicura che tutto, dal testo del gioco ai commenti di codice, venga visualizzato correttamente -->
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- üîÑ COMPATIBILIT√Ä BROWSER: Garantisce il rendering moderno di IE -->
    <!-- Dice a Internet Explorer di utilizzare il suo motore di rendering pi√π moderno -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- üì± CONFIGURAZIONE RESPONSIVE: "Questo gioco si adatta a qualsiasi schermo!" -->
    <!-- Rende il nostro gioco correttamente dimensionato su tutti i dispositivi, dai telefoni ai desktop -->
    
    <title>Learn Intermediate OOP by Building a Platformer Game</title>
    <!-- üìë TITOLO SCHEDA: Scopo educativo chiaramente definito -->
    <!-- OOP = Programmazione Orientata agli Oggetti, la base dello sviluppo di giochi moderni -->
    
    <style>
      /* üé® ===== STILI CSS: Il Mondo Visivo del Gioco ===== */
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        /* üßπ PULIZIA TOTALE: Resetta tutti gli spazi predefiniti del browser */
        /* Assicura che il nostro gioco abbia un aspetto coerente su tutti i browser */
        /* √à come livellare il terreno prima di costruire il nostro mondo di gioco */
      }
      
      :root {
        --main-bg-color: #0a0a23;
        --section-bg-color: #ffffff;
        --golden-yellow: #feac32;
        /* üé® VARIABILI COLORE: Definizione centrale della palette */
        /* L'uso di variabili CSS rende i cambiamenti di tema facili e coerenti */
        /* √à come definire i colori principali per il nostro mondo di gioco */
      }
      
      body {
        background-color: var(--main-bg-color);
        /* üåå SFONDO BLU SCURO: Crea un'atmosfera immersiva */
        /* Gli sfondi scuri riducono l'affaticamento degli occhi durante il gioco */
      }
      
      .start-screen {
        background-color: var(--section-bg-color);
        width: 100%;
        position: absolute;
        top: 50%;
        left: 50%;
        margin-right: -50%;
        transform: translate(-50%, -50%);
        /* ‚öñÔ∏è CENTRATURA PERFETTA: Il trucco transform centra l'elemento con precisione */
        /* Centrato orizzontalmente E verticalmente indipendentemente dalla dimensione del contenuto */
        
        border-radius: 30px;
        /* üîÑ ANGOLI ARROTONDATI: Ammorbidiscono l'aspetto visivo */
        /* Crea un'interfaccia utente pi√π moderna e amichevole per i giocatori */
        
        padding: 20px;
        padding-bottom: 5px;
        /* üìè SPAZIATURA INTERNA: Spazio di respiro per il contenuto */
        /* Un padding diverso sopra/sotto crea equilibrio visivo */
      }
      
      .main-title {
        text-align: center;
        /* ‚öñÔ∏è TITOLO CENTRATO: Punto focale della schermata iniziale */
        /* La prima cosa che i giocatori vedono - crea gerarchia e focus */
      }
      
      .instructions {
        text-align: center;
        font-size: 1.2rem;
        margin: 15px;
        line-height: 2rem;
        /* üìù ISTRUZIONI CHIARE: Testo ottimizzato per la leggibilit√† */
        /* font-size: 1.2rem = 20% pi√π grande del testo predefinito */
        /* line-height: 2rem = interlinea doppia per una lettura pi√π facile */
        /* Assicura che i giocatori comprendano come giocare prima di iniziare */
      }
      
      .btn {
        cursor: pointer;
        /* üëÜ CURSORE A MANO: Indicazione visiva che l'elemento √® cliccabile */
        
        width: 100px;
        margin: 10px;
        /* üìè DIMENSIONI PULSANTE: Dimensione confortevole per l'area di click */
        /* 100px di larghezza con 10px di margine crea una buona spaziatura */
        
        color: #0a0a23;
        font-size: 18px;
        /* üî§ STILE TESTO: Testo scuro su pulsante chiaro per leggibilit√† */
        /* 18px di dimensione assicura che il testo sia facilmente leggibile su tutti i dispositivi */
        
        background-color: var(--golden-yellow);
        background-image: linear-gradient(#fecc4c, #ffac33);
        /* üåÖ SFONDO GRADIENTE: Crea effetto pulsante 3D */
        /* Parte superiore pi√π chiara, inferiore pi√π scura crea l'illusione di luce dall'alto */
        
        border-color: var(--golden-yellow);
        border-width: 3px;
        /* üî≤ STILE BORDO: Bordo spesso che si abbina allo sfondo */
        /* 3px di larghezza rende il bordo chiaramente visibile */
      }
      
      .btn:hover {
        background-image: linear-gradient(#ffcc4c, #f89808);
        /* ‚ú® EFFETTO HOVER: Il pulsante si illumina quando il mouse ci passa sopra */
        /* Feedback visivo prima di cliccare migliora l'esperienza utente */
        /* Un gradiente leggermente diverso crea un aspetto "attivato" */
      }
      
      .btn-container {
        display: flex;
        align-items: center;
        justify-content: center;
        /* üì¶ CENTRATURA FLEXBOX: Allineamento orizzontale perfetto */
        /* Approccio moderno alla centratura con CSS */
        /* Assicura che il pulsante sia perfettamente centrato indipendentemente dalla dimensione dello schermo */
      }
      
      .checkpoint-screen {
        position: absolute;
        left: 0;
        right: 0;
        margin-left: auto;
        margin-right: auto;
        /* ‚öñÔ∏è CENTRATURA ORIZZONTALE: Tecnica tradizionale */
        /* Impostare left/right a 0 con margini automatici centra l'elemento */
        
        width: 100%;
        text-align: center;
        background-color: var(--section-bg-color);
        border-radius: 20px;
        padding: 10px;
        /* üìã STILE POPUP: Notifica pulita e leggibile */
        /* Sfondo bianco con angoli arrotondati per un look moderno */
        
        display: none;
        /* üôà INIZIALMENTE NASCOSTO: Appare solo ai checkpoint */
        /* JavaScript cambier√† questo in "block" quando necessario */
      }
      
      #canvas {
        display: none;
        /* üôà CANVAS NASCOSTO: Rivelato quando il gioco inizia */
        /* Inizialmente nascosto per mostrare invece la schermata iniziale */
      }
      
      @media (min-width: 768px) {
        /* üì± BREAKPOINT RESPONSIVE: Tablet e schermi pi√π grandi */
        /* 768px √® la larghezza standard di un tablet in portrait */
        
        .start-screen {
          width: 60%;
          max-width: 700px;
          /* üìè DIMENSIONAMENTO DESKTOP: Pannello pi√π stretto e centrato */
          /* Impedisce che la schermata iniziale si estenda troppo sui grandi schermi */
          /* 60% di larghezza con 700px di massimo crea una larghezza di lettura ideale */
        }
      
        .checkpoint-screen {
          max-width: 300px;
          /* üìè DIMENSIONAMENTO NOTIFICHE: Compatto su schermi pi√π grandi */
          /* 300px √® abbastanza largo per il contenuto ma non invadente */
        }
      }
    </style>
  </head>
  <body>
    <!-- üéÆ ===== INTERFACCIA DEL GIOCO: La Finestra del Giocatore sul Mondo ===== -->
    
    <div class="start-screen">
      <!-- üé¨ SCHERMATA INIZIALE: Il menu iniziale del gioco -->
      <!-- Come la schermata del titolo dei giochi arcade classici! -->
      
      <h1 class="main-title">freeCodeCamp Code Warrior</h1>
      <!-- üìë TITOLO DEL GIOCO: Stabilisce il tema e il brand -->
      <!-- "Code Warrior" suggerisce un'avventura a tema coding -->
      
      <p class="instructions">
        Help the main player navigate to the yellow checkpoints.
      </p>
      <!-- üìù OBIETTIVO DEL GIOCO: Descrizione chiara degli obiettivi -->
      <!-- Dice esattamente al giocatore cosa deve fare -->
      
      <p class="instructions">
        Use the keyboard arrows to move the player around.
      </p>
      <!-- üéÆ SCHEMA DI CONTROLLO 1: Spiegazione dei controlli di movimento -->
      <!-- I tasti freccia sono intuitivi per il movimento 2D -->
      
      <p class="instructions">You can also use the spacebar to jump.</p>
      <!-- üéÆ SCHEMA DI CONTROLLO 2: Meccanica di salto spiegata -->
      <!-- La barra spaziatrice √® il pulsante di salto standard nella maggior parte dei platformer -->

      <div class="btn-container">
        <!-- üì¶ WRAPPER PULSANTE: Centra il pulsante di avvio -->
        
        <button class="btn" id="start-btn">Start Game</button>
        <!-- üéØ PULSANTE AVVIO: Inizia il gioco -->
        <!-- Elemento interattivo cruciale con ID unico per JavaScript -->
      </div>
    </div>

    <div class="checkpoint-screen">
      <!-- üèÜ NOTIFICA CHECKPOINT: Appare quando si raggiungono gli obiettivi -->
      <!-- Fornisce feedback positivo per i traguardi del giocatore -->
      
      <h2>Congrats!</h2>
      <!-- üéâ INTESTAZIONE CELEBRATIVA: Rinforzo positivo -->
      <!-- Un messaggio di congratulazioni crea soddisfazione -->
      
      <p>You reached the last checkpoint.</p>
      <!-- üìù MESSAGGIO DI TRAGUARDO: Chiarisce cosa √® successo -->
      <!-- Sar√† aggiornato via JavaScript per i diversi checkpoint -->
    </div>

    <canvas id="canvas"></canvas>
    <!-- üñºÔ∏è ELEMENTO CANVAS: La superficie di rendering effettiva del gioco -->
    <!-- Il Canvas HTML5 √® come una tavola da disegno vuota per il nostro JavaScript -->
    <!-- Tutte le visuali del gioco saranno disegnate qui programmaticamente -->

    <script>
      /* üéÆ ===== JAVASCRIPT: Il Motore del Gioco! ===== */
      
      /* üîç ===== SELEZIONE ELEMENTI DOM: Collegamento di JS a HTML ===== */
      
      const startBtn = document.getElementById("start-btn");
      /* üîò RIFERIMENTO PULSANTE AVVIO: Accesso diretto tramite ID */
      /* getElementById √® il metodo di selezione pi√π veloce - perfetto per elementi critici */
      /* Come afferrare l'interruttore di accensione per il motore del nostro gioco */
      
      const canvas = document.getElementById("canvas");
      /* üñºÔ∏è RIFERIMENTO CANVAS: La nostra superficie di disegno */
      /* Questo elemento diventer√† il nostro intero mondo di gioco */
      /* Come ottenere una tela vuota prima di dipingere un capolavoro */
      
      const startScreen = document.querySelector(".start-screen");
      /* üé¨ RIFERIMENTO SCHERMATA INIZIALE: Uso del selettore di classe */
      /* querySelector trova il primo elemento corrispondente con questa classe */
      /* Lo nasconderemo quando il gioco inizia */
      
      const checkpointScreen = document.querySelector(".checkpoint-screen");
      /* üèÜ RIFERIMENTO SCHERMATA CHECKPOINT: Per i messaggi di vittoria */
      /* Questo popup apparir√† quando i giocatori raggiungono i checkpoint */
      
      const checkpointMessage = document.querySelector(".checkpoint-screen > p");
      /* üìù RIFERIMENTO MESSAGGIO: Selettore figlio diretto */
      /* Il simbolo ">" seleziona SOLO i figli diretti (non i nipoti) */
      /* Aggiorneremo questo testo quando verranno raggiunti diversi checkpoint */
      
      /* üé® ===== CONFIGURAZIONE CANVAS: Preparazione della Superficie di Disegno ===== */
      
      const ctx = canvas.getContext("2d");
      /* üñåÔ∏è CONTESTO DI DISEGNO: L'API di disegno effettiva */
      /* getContext("2d") ci d√† accesso agli strumenti di disegno Canvas */
      /* Come ottenere un pennello da usare sulla nostra tela */
      /* √à ci√≤ che useremo per disegnare forme, colori e il mondo di gioco */
      
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      /* üìè DIMENSIONI CANVAS: Dimensione a schermo intero */
      /* L'impostazione di larghezza/altezza in JS sovrascrive qualsiasi dimensionamento CSS */
      /* Questo crea un rapporto pixel 1:1 per un rendering nitido */
      /* Senza questo, il canvas avrebbe un default di 300x150px e risulterebbe sfocato se allungato */
      
      /* üåç ===== COSTANTI DELLA FISICA DI GIOCO: Le Regole del Nostro Mondo ===== */
      
      const gravity = 0.5;
      /* ‚¨áÔ∏è COSTANTE DI GRAVIT√Ä: Forza che tira il giocatore verso il basso */
      /* Questa non √® la gravit√† realistica della Terra (9,8 m/s¬≤) ma un valore che "si sente bene" */
      /* Ogni frame aggiunge 0,5 alla velocit√† verticale ‚Üí caduta accelerata */
      /* Valori pi√π alti = caduta pi√π rapida, valori pi√π bassi = salti pi√π fluttuanti */
      
      let isCheckpointCollisionDetectionActive = true;
      /* üö¶ FLAG DI COLLISIONE: Controlla il rilevamento dei checkpoint */
      /* Questo booleano funziona come un interruttore on/off per le interazioni con i checkpoint */
      /* Quando √® false, impedisce che lo stesso checkpoint attivi pi√π volte */
      /* Fondamentale per evitare che il checkpoint si attivi 60 volte al secondo! */
      
      /* üìè ===== FUNZIONE DI SCALATURA: Elementi di Gioco Responsive ===== */
      
      const proportionalSize = (size) => {
        return innerHeight < 500 ? Math.ceil((size / 500) * innerHeight) : size;
        /* üì± SCALATURA ADATTIVA: Gli elementi si ridimensionano per schermi piccoli */
        /* Se l'altezza dello schermo < 500px: scala tutto proporzionalmente */
        /* Formula: (dimensione √∑ altezza di riferimento) √ó altezza effettiva */
        /* Math.ceil() arrotonda per eccesso per evitare elementi di dimensione zero */
        /* Su schermi pi√π alti: usa i valori di dimensione originali */
        /* Come avere un progetto responsive per il nostro mondo di gioco */
      }
      
      /* üßç ===== CLASSE PLAYER: Il Personaggio Principale ===== */
      
      class Player {
        /* üìò DEFINIZIONE CLASSE: Blueprint per creare i giocatori */
        /* Le classi sono modelli che definiscono propriet√† e comportamenti */
        /* Come definire cosa fa un "giocatore" nel nostro universo di gioco */
        
        constructor() {
          /* üèóÔ∏è METODO COSTRUTTORE: Eseguito quando si crea un nuovo Player */
          /* Questo metodo inizializza tutte le propriet√† del giocatore */
          /* Come costruire il personaggio giocatore da zero */
          
          this.position = {
            x: proportionalSize(10),
            y: proportionalSize(400),
          };
          /* üìç POSIZIONE INIZIALE: Dove inizia il giocatore */
          /* Coordinate dall'angolo in alto a sinistra dello schermo */
          /* L'uso di proportionalSize garantisce che funzioni su tutti i formati di schermo */
          
          this.velocity = {
            x: 0, /* Velocit√† orizzontale (pixel per frame) */
            y: 0, /* Velocit√† verticale (pixel per frame) */
          };
          /* üèéÔ∏è VETTORE VELOCIT√Ä: Velocit√† e direzione */
          /* Componenti x/y separate consentono movimento orizzontale/verticale indipendente */
          /* 0 significa fermo in ogni direzione */
          
          this.width = proportionalSize(40);
          this.height = proportionalSize(40);
          /* üìè DIMENSIONI GIOCATORE: Dimensione del personaggio */
          /* 40x40px crea un giocatore quadrato (responsive su piccoli schermi) */
          /* La dimensione influisce sia sugli aspetti visivi che sul rilevamento delle collisioni */
        }
        
        draw() {
          /* üé® METODO DI DISEGNO: Renderizza il giocatore sullo schermo */
          /* Chiamato ogni frame per mostrare il giocatore */
          
          ctx.fillStyle = "#99c9ff";
          /* üé® COLORE GIOCATORE: Azzurro chiaro */
          /* Imposta il "colore della pittura" prima di disegnare */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DISEGNA RETTANGOLO: Crea la forma del giocatore */
          /* fillRect(x, y, width, height) disegna un rettangolo pieno */
          /* Questo semplice quadrato rappresenta il nostro personaggio */
          /* Nei giochi professionali, questo sarebbe sostituito con immagini sprite */
        }
        
        update() {
          /* üîÑ METODO DI AGGIORNAMENTO: Fisica e logica di gioco */
          /* Chiamato ogni frame (60 volte al secondo) */
          /* Il cuore del comportamento del giocatore nel gioco */
          
          this.draw();
          /* üé® RENDERIZZA PRIMA: Assicura che il giocatore sia visibile */
          /* Disegna sempre prima di muoversi per prevenire glitch visivi */
          
          this.position.x += this.velocity.x;
          this.position.y += this.velocity.y;
          /* üö∂ FISICA DEL MOVIMENTO: La posizione cambia in base alla velocit√† */
          /* Questa √® l'equazione fondamentale del movimento: posizione += velocit√† */
          /* La direzione e la velocit√† del movimento dipendono dai valori di velocit√† */
          
          if (this.position.y + this.height + this.velocity.y <= canvas.height) {
            /* üå°Ô∏è CONTROLLO GRAVIT√Ä: Il giocatore √® ancora in aria? */
            /* La condizione verifica se il giocatore non ha raggiunto il fondo dello schermo */
            /* Posizione bordo inferiore = posizione y + altezza */
            
            if (this.position.y < 0) {
              /* üõë CONTROLLO LIMITE SUPERIORE: Il giocatore sta cercando di uscire dallo schermo? */
              /* y < 0 significa che il giocatore sta cercando di saltare sopra il canvas */
              
              this.position.y = 0;
              this.velocity.y = gravity;
              /* üîÑ COLLISIONE CON SOFFITTO: Rimbalza il giocatore verso il basso */
              /* Impedisce di andare sopra lo schermo e inizia a cadere */
            }
            
            this.velocity.y += gravity;
            /* ‚¨áÔ∏è APPLICA GRAVIT√Ä: Aumenta la velocit√† di caduta */
            /* Questo crea accelerazione - la caduta diventa pi√π veloce nel tempo */
            /* La base della fisica di salto realistica! */
          } else {
            /* üõë COLLISIONE COL PAVIMENTO: Il giocatore ha raggiunto il fondo */
            
            this.velocity.y = 0;
            /* üõë FERMA LA CADUTA: Imposta la velocit√† verticale a zero */
            /* Impedisce al giocatore di cadere attraverso il pavimento */
          }
      
          if (this.position.x < this.width) {
            /* üõë CONTROLLO LIMITE SINISTRO: Impedisce di uscire dallo schermo a sinistra */
            
            this.position.x = this.width;
            /* üîô RESPINGE: Imposta la posizione al bordo dello schermo */
            /* Crea un muro invisibile al bordo sinistro dello schermo */
          }
      
          if (this.position.x >= canvas.width - this.width * 2) {
            /* üõë CONTROLLO LIMITE DESTRO: Impedisce di uscire dallo schermo a destra */
            
            this.position.x = canvas.width - this.width * 2;
            /* üîô RESPINGE: Imposta la posizione al bordo dello schermo */
            /* La moltiplicazione crea un limite visivo migliore */
          }
        }
      }
      
      /* üß± ===== CLASSE PLATFORM: Il Terreno Solido ===== */
      
      class Platform {
        /* üìò DEFINIZIONE CLASSE: Blueprint per le piattaforme */
        /* Ogni piattaforma √® una superficie su cui il giocatore pu√≤ stare */
        
        constructor(x, y) {
          /* üèóÔ∏è COSTRUTTORE CON PARAMETRI: Piattaforme personalizzabili */
          /* Prende le coordinate x,y per posizionare piattaforme ovunque */
          /* Come posizionare blocchi di costruzione nel nostro mondo */
          
          this.position = {
            x, /* Abbreviazione per x: x */
            y, /* Abbreviazione per y: y */
          };
          /* üìç POSIZIONE PIATTAFORMA: Posizionamento personalizzato */
          /* JS moderno permette l'abbreviazione quando nome propriet√† = nome variabile */
          /* Questo crea la piattaforma alle coordinate esatte specificate */
          
          this.width = 200;
          this.height = proportionalSize(40);
          /* üìè DIMENSIONE PIATTAFORMA: Larghezza e altezza */
          /* 200px di larghezza crea piattaforme su cui il giocatore pu√≤ correre */
          /* L'altezza si adatta alla dimensione dello schermo per coerenza */
        }
        
        draw() {
          /* üé® METODO DI DISEGNO: Renderizza la piattaforma sullo schermo */
          
          ctx.fillStyle = "#acd157";
          /* üé® COLORE PIATTAFORMA: Verde chiaro */
          /* Un colore simile all'erba distingue le piattaforme dal giocatore */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DISEGNA RETTANGOLO: Crea la forma della piattaforma */
          /* Un semplice rettangolo rappresenta ogni piattaforma */
        }
      }
      
      /* üö© ===== CLASSE CHECKPOINT: I Marcatori degli Obiettivi ===== */
      
      class CheckPoint {
        /* üìò DEFINIZIONE CLASSE: Blueprint per i marcatori degli obiettivi */
        /* Questi sono gli obiettivi che il giocatore deve raggiungere */
        
        constructor(x, y, z) {
          /* üèóÔ∏è COSTRUTTORE CON PARAMETRI: Checkpoint personalizzabili */
          /* x,y = posizione, z = numero/sequenza del checkpoint */
          
          this.position = {
            x,
            y,
          };
          /* üìç POSIZIONE CHECKPOINT: Posizionamento personalizzato */
          /* Usa la stessa sintassi abbreviata di Platform */
          
          this.width = proportionalSize(40);
          this.height = proportionalSize(70);
          /* üìè DIMENSIONE CHECKPOINT: Alto e stretto */
          /* Pi√π alto del giocatore per essere facilmente visibile */
          
          this.claimed = false;
          /* üö© FLAG CLAIMED: Tiene traccia dello stato del checkpoint */
          /* false = non ancora raggiunto, true = gi√† raccolto */
          /* Come una bandierina virtuale "Sono stato qui" che il giocatore pianta */
        };
      
        draw() {
          /* üé® METODO DI DISEGNO: Renderizza il checkpoint sullo schermo */
          
          ctx.fillStyle = "#f1be32";
          /* üé® COLORE CHECKPOINT: Giallo dorato */
          /* Il colore brillante fa risaltare i checkpoint come obiettivi */
          
          ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
          /* üì¶ DISEGNA RETTANGOLO: Crea la forma del checkpoint */
          /* Il rettangolo verticale assomiglia a una bandiera del traguardo */
        }
        
        claim() {
          /* üèÅ METODO CLAIM: "Raccoglie" il checkpoint */
          /* Chiamato quando il giocatore raggiunge questo checkpoint */
          
          this.width = 0;
          this.height = 0;
          /* üôà RENDI INVISIBILE: Dimensioni zero lo nascondono */
          /* Piuttosto che rimuoverlo dall'array, lo rendiamo invisibile */
          
          this.position.y = Infinity;
          /* üå† MANDA VIA: Sposta fuori dallo schermo */
          /* Infinity garantisce che non possa mai pi√π essere colpito */
          /* Questo √® pi√π sicuro che modificare l'array durante l'iterazione */
          
          this.claimed = true;
          /* üö© SEGNA COME CLAIMED: Aggiorna il flag di stato */
          /* Questo aiuta a tenere traccia del progresso e della sequenza dei checkpoint */
          /* Usato per la logica condizionale nel rilevamento delle collisioni */
        }
      };
      
      /* üè≠ ===== CREAZIONE OGGETTI DI GIOCO: Costruzione del Mondo ===== */
      
      const player = new Player();
      /* üßç CREA GIOCATORE: Istanza della classe Player */
      /* new Player() chiama il costruttore e crea un oggetto funzionante */
      /* Come premere il pulsante "stampa" sul nostro blueprint del giocatore */
      
      const platformPositions = [
        { x: 500, y: proportionalSize(450) },
        { x: 700, y: proportionalSize(400) },
        { x: 850, y: proportionalSize(350) },
        { x: 900, y: proportionalSize(350) },
        { x: 1050, y: proportionalSize(150) },
        { x: 2500, y: proportionalSize(450) },  /* Gap grande ‚Üí sfida! */
        { x: 2900, y: proportionalSize(400) },
        { x: 3150, y: proportionalSize(350) },
        { x: 3900, y: proportionalSize(450) },  /* Altro gap */
        { x: 4200, y: proportionalSize(400) },
        { x: 4400, y: proportionalSize(200) },
        { x: 4700, y: proportionalSize(150) },
      ];
      /* üó∫Ô∏è DESIGN DEL LIVELLO: Array delle coordinate delle piattaforme */
      /* Ogni oggetto contiene la posizione x,y per una piattaforma */
      /* Questo √® il nostro "progetto del livello" - separa i dati dalla logica */
      /* I commenti indicano dove si verificano gap impegnativi nel livello */
      
      const platforms = platformPositions.map(
        (platform) => new Platform(platform.x, platform.y)
      );
      /* üè≠ CREAZIONE PIATTAFORME: Trasforma i dati in oggetti */
      /* map() converte ogni posizione in una Platform funzionante */
      /* √à come una catena di montaggio: dati in ingresso ‚Üí oggetti in uscita */
      /* Arrow function con return implicito crea ogni Platform */
      
      const checkpointPositions = [
        { x: 1170, y: proportionalSize(80), z: 1 },
        { x: 2900, y: proportionalSize(330), z: 2 },
        { x: 4800, y: proportionalSize(80), z: 3 },
      ];
      /* üö© POSIZIONI CHECKPOINT: Coordinate degli obiettivi */
      /* Tre checkpoint sono posizionati in punti strategici del livello */
      /* Il valore z tiene traccia del numero di sequenza del checkpoint */
      
      const checkpoints = checkpointPositions.map(
        (checkpoint) => new CheckPoint(checkpoint.x, checkpoint.y, checkpoint.z)
      );
      /* üè≠ CREAZIONE CHECKPOINT: Trasforma i dati in oggetti */
      /* Stesso schema di mapping delle piattaforme, crea oggetti CheckPoint */
      
      /* üîÑ ===== GAME LOOP: Il Motore di Animazione ===== */
      
      const animate = () => {
        /* üé¨ GAME LOOP PRINCIPALE: Funzione eseguita ogni frame */
        /* Questo √® il battito cardiaco del nostro gioco - tutto accade qui */
        
        requestAnimationFrame(animate);
        /* üîÑ CREAZIONE LOOP: API di animazione del browser */
        /* Chiede al browser di chiamare animate() prima del prossimo repaint */
        /* Crea un ciclo fluido a 60fps ottimizzato per le prestazioni */
        /* Auto-referenziale - animate chiama se stesso creando un loop infinito */
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        /* üßπ PULISCI CANVAS: Cancella il frame precedente */
        /* Come cancellare una lavagna prima di disegnare il prossimo stato */
        /* Senza questo, i movimenti lascerebbero tracce dietro di loro */
      
        platforms.forEach((platform) => {
          platform.draw();
        });
        /* üé® DISEGNA PIATTAFORME: Renderizza tutte le piattaforme */
        /* forEach esegue la funzione su ogni elemento dell'array */
        /* Viene chiamato il metodo draw() di ogni piattaforma per renderizzarla */
      
        checkpoints.forEach(checkpoint => {
          checkpoint.draw();
        });
        /* üé® DISEGNA CHECKPOINT: Renderizza tutti i checkpoint */
        /* Stesso schema delle piattaforme - disegna ogni checkpoint */
      
        player.update();
        /* üîÑ AGGIORNA GIOCATORE: Fisica e rendering */
        /* Questo chiama il metodo update del giocatore che:
           1. Disegna il giocatore
           2. Aggiorna la posizione in base alla velocit√†
           3. Applica gravit√† e controlli dei limiti */
      
        /* üì∑ ===== MOVIMENTO DELLA CAMERA: Scorrimento del Mondo ===== */
        
        if (keys.rightKey.pressed && player.position.x < proportionalSize(400)) {
          /* üèÉ‚Äç‚ôÇÔ∏è MOVIMENTO GIOCATORE DESTRA: Sposta il giocatore quando √® lontano dal centro */
          /* Quando il tasto destro √® premuto E il giocatore √® a sinistra del punto centrale */
          
          player.velocity.x = 5;
          /* ‚û°Ô∏è IMPOSTA VELOCIT√Ä: Muove il giocatore a destra */
          /* 5 pixel per frame creano un movimento fluido */
        } else if (keys.leftKey.pressed && player.position.x > proportionalSize(100)) {
          /* üèÉ‚Äç‚ôÇÔ∏è MOVIMENTO GIOCATORE SINISTRA: Sposta il giocatore quando √® lontano dal bordo sinistro */
          /* Quando il tasto sinistro √® premuto E il giocatore √® a destra del limite sinistro */
          
          player.velocity.x = -5;
          /* ‚¨ÖÔ∏è IMPOSTA VELOCIT√Ä: Muove il giocatore a sinistra */
          /* Velocit√† negativa significa movimento verso sinistra */
        } else {
          /* üõë POSIZIONE CENTRALE: Giocatore vicino al centro o ai bordi */
          
          player.velocity.x = 0;
          /* üõë FERMA MOVIMENTO ORIZZONTALE: Giocatore fermo */
          /* Reimposta la velocit√† a zero - il giocatore smette di muoversi orizzontalmente */
      
          /* üåé SCORRIMENTO MONDO: Sposta l'ambiente invece del giocatore */
          /* Questo crea l'illusione di una camera che segue il giocatore */
          
          if (keys.rightKey.pressed && isCheckpointCollisionDetectionActive) {
            /* ‚û°Ô∏è SCORRI DESTRA: Sposta il mondo quando il giocatore √® centrato */
            /* Attivo solo quando la rilevazione delle collisioni con checkpoint √® abilitata */
            
            platforms.forEach((platform) => {
              platform.position.x -= 5;
              /* ‚¨ÖÔ∏è SPOSTA PIATTAFORME A SINISTRA: Il mondo scorre in direzione opposta al giocatore */
              /* Crea l'illusione che il giocatore si muova verso destra */
            });
      
            checkpoints.forEach((checkpoint) => {
              checkpoint.position.x -= 5;
              /* ‚¨ÖÔ∏è SPOSTA CHECKPOINT A SINISTRA: Mantiene sincronizzati con le piattaforme */
              /* Tutto nel mondo si muove insieme per uno scorrimento coerente */
            });
          
          } else if (keys.leftKey.pressed && isCheckpointCollisionDetectionActive) {
            /* ‚¨ÖÔ∏è SCORRI SINISTRA: Sposta il mondo quando il giocatore √® centrato */
            
            platforms.forEach((platform) => {
              platform.position.x += 5;
              /* ‚û°Ô∏è SPOSTA PIATTAFORME A DESTRA: Il mondo scorre in direzione opposta al giocatore */
              /* Crea l'illusione che il giocatore si muova verso sinistra */
            });
      
            checkpoints.forEach((checkpoint) => {
              checkpoint.position.x += 5;
              /* ‚û°Ô∏è SPOSTA CHECKPOINT A DESTRA: Mantiene sincronizzati con le piattaforme */
            });
          }
        }
      
        /* üí• ===== RILEVAMENTO COLLISIONI CON PIATTAFORME ===== */
        
        platforms.forEach((platform) => {
          /* üîç CONTROLLA OGNI PIATTAFORMA: Itera attraverso tutte le piattaforme */
          
          const collisionDetectionRules = [
            player.position.y + player.height <= platform.position.y,
            /* ‚¨áÔ∏è REGOLA 1: Fondo del giocatore sopra la parte superiore della piattaforma */
            /* Assicura che il giocatore stia scendendo sulla piattaforma dall'alto */
            
            player.position.y + player.height + player.velocity.y >= platform.position.y,
            /* ‚¨áÔ∏è REGOLA 2: La prossima posizione del giocatore intersecher√† la piattaforma */
            /* Prevede la collisione basata sulla velocit√† attuale */
            
            player.position.x >= platform.position.x - player.width / 2,
            /* ‚¨ÖÔ∏è REGOLA 3: Giocatore non troppo a sinistra della piattaforma */
            /* Controllo posizione orizzontale - bordo sinistro */
            
            player.position.x <=
              platform.position.x + platform.width - player.width / 3,
            /* ‚û°Ô∏è REGOLA 4: Giocatore non troppo a destra della piattaforma */
            /* Controllo posizione orizzontale - bordo destro */
          ];
      
          if (collisionDetectionRules.every((rule) => rule)) {
            /* ‚úÖ TUTTE LE REGOLE VERE: In piedi sulla piattaforma */
            /* every() verifica se TUTTE le condizioni restituiscono true */
            /* Questo √® come un AND logico tra tutte le condizioni */
            
            player.velocity.y = 0;
            /* üõë FERMA CADUTA: Atterra sulla piattaforma */
            /* Velocit√† verticale zero impedisce di cadere attraverso la piattaforma */
            
            return;
            /* üö™ ESCI DAL LOOP: Salta le piattaforme rimanenti */
            /* Una volta trovata una collisione, non c'√® bisogno di controllare le altre */
          }
      
          /* üí• COLLISIONE DAL BASSO: Colpisce la piattaforma da sotto */
          
          const platformDetectionRules = [
            player.position.x >= platform.position.x - player.width / 2,
            /* ‚¨ÖÔ∏è REGOLA 1: Controllo sovrapposizione orizzontale (sinistra) */
            
            player.position.x <=
              platform.position.x + platform.width - player.width / 3,
            /* ‚û°Ô∏è REGOLA 2: Controllo sovrapposizione orizzontale (destra) */
            
            player.position.y + player.height >= platform.position.y,
            /* ‚¨ÜÔ∏è REGOLA 3: Fondo del giocatore sotto la parte superiore della piattaforma */
            
            player.position.y <= platform.position.y + platform.height,
            /* ‚¨áÔ∏è REGOLA 4: Parte superiore del giocatore sopra la parte inferiore della piattaforma */
          ];
      
          if (platformDetectionRules.every(rule => rule)) {
            /* ‚úÖ TUTTE LE REGOLE VERE: Colpisce la piattaforma dal basso */
            
            player.position.y = platform.position.y + player.height;
            /* ‚¨áÔ∏è SPINGE GI√ô: Sposta il giocatore sotto la piattaforma */
            /* Impedisce di rimanere bloccati all'interno della piattaforma */
            
            player.velocity.y = gravity;
            /* ‚¨áÔ∏è INIZIA A CADERE: Applica la gravit√† */
            /* Rimbalza il giocatore verso il basso dopo aver colpito con la testa */
          };
        });
      
        /* üö© ===== RILEVAMENTO COLLISIONI CON CHECKPOINT ===== */
        
        checkpoints.forEach((checkpoint, index, checkpoints) => {
          /* üîç CONTROLLA OGNI CHECKPOINT: Itera attraverso tutti i checkpoint */
          /* index = posizione nell'array, checkpoints = l'array completo */
          
          const checkpointDetectionRules = [
            player.position.x >= checkpoint.position.x,
            /* ‚û°Ô∏è REGOLA 1: Bordo destro del giocatore oltre il bordo sinistro del checkpoint */
            
            player.position.y >= checkpoint.position.y,
            /* ‚¨áÔ∏è REGOLA 2: Giocatore sotto la parte superiore del checkpoint */
            
            player.position.y + player.height <=
              checkpoint.position.y + checkpoint.height,
            /* ‚¨ÜÔ∏è REGOLA 3: Giocatore entro i limiti verticali del checkpoint */
            
            isCheckpointCollisionDetectionActive,
            /* üö¶ REGOLA 4: Il sistema di rilevamento collisioni √® attivo */
            /* Impedisce attivazioni multiple quando l'interruttore globale √® spento */
            
            player.position.x - player.width <=
              checkpoint.position.x - checkpoint.width + player.width * 0.9,
            /* ‚¨ÖÔ∏è REGOLA 5: Controllo di allineamento orizzontale complesso */
            /* Assicura che il giocatore sia posizionato correttamente rispetto al checkpoint */
            
            index === 0 || checkpoints[index - 1].claimed === true,
            /* üî¢ REGOLA 6: Controllo ordine checkpoint */
            /* O questo √® il primo checkpoint O quello precedente √® stato reclamato */
            /* Forza la raccolta sequenziale dei checkpoint */
          ];
      
          if (checkpointDetectionRules.every((rule) => rule)) {
            /* ‚úÖ TUTTE LE REGOLE VERE: Checkpoint raggiunto */
            
            checkpoint.claim();
            /* üèÅ RECLAMA CHECKPOINT: Segna come raggiunto */
            /* Questo nasconde il checkpoint e lo marca come claimed */
      
            if (index === checkpoints.length - 1) {
              /* üèÜ CHECKPOINT FINALE: Ultimo nell'array */
              /* Lunghezza - 1 √® l'indice dell'ultimo elemento */
              
              isCheckpointCollisionDetectionActive = false;
              /* üö´ DISABILITA COLLISIONI: Il gioco effettivamente finisce */
              /* Impedisce ulteriori attivazioni di checkpoint */
              
              showCheckpointScreen("You reached the final checkpoint!");
              /* üéâ MESSAGGIO DI VITTORIA: Traguardo finale */
              /* Mostra un messaggio di congratulazioni con testo personalizzato */
              
              movePlayer("ArrowRight", 0, false);
              /* üõë FERMA GIOCATORE: Previene il movimento dopo la vittoria */
              /* Reimposta lo stato del movimento per far fermare il giocatore */
            } else if (player.position.x >= checkpoint.position.x && player.position.x <= checkpoint.position.x + 40) {
              /* ‚úÖ CHECKPOINT REGOLARE: Non l'ultimo */
              /* Controllo posizione aggiuntivo assicura il corretto timing di attivazione */
              
              showCheckpointScreen("You reached a checkpoint!");
              /* üéâ MESSAGGIO DI PROGRESSO: Traguardo intermedio */
            }
          };
        });
      }
      
      /* üéÆ ===== TRACCIAMENTO STATO TASTIERA ===== */
      
      const keys = {
        rightKey: {
          pressed: false
        },
        leftKey: {
          pressed: false
        }
      };
      /* üéÆ OGGETTO STATO TASTIERA: Tiene traccia dei tasti premuti */
      /* Oggetti nidificati: keys ‚Üí rightKey ‚Üí pressed */
      /* Uso di flag booleani invece di controllare lo stato dei tasti ad ogni frame */
      /* Questo permette un movimento fluido e coerente */
      
      const movePlayer = (key, xVelocity, isPressed) => {
        /* üèÉ‚Äç‚ôÇÔ∏è FUNZIONE MOVIMENTO GIOCATORE: Elabora le azioni dei tasti */
        /* key = quale tasto √® stato premuto */
        /* xVelocity = quanto velocemente muoversi */
        /* isPressed = tasto premuto o rilasciato? */
        
        if (!isCheckpointCollisionDetectionActive) {
          /* üö´ CONTROLLO FINE GIOCO: Blocca il movimento se il gioco √® finito */
          
          player.velocity.x = 0;
          player.velocity.y = 0;
          /* üõë CONGELA GIOCATORE: Ferma ogni movimento */
          
          return;
          /* üö™ ESCI DALLA FUNZIONE: Salta il codice rimanente */
        }
      
        switch (key) {
          /* üîÄ SWITCH TASTI: Azione diversa per ogni tasto */
          /* Modo efficiente per gestire pi√π opzioni di tasto */
          
          case "ArrowLeft":
            /* ‚¨ÖÔ∏è FRECCIA SINISTRA: Muove il giocatore a sinistra */
            
            keys.leftKey.pressed = isPressed;
            /* üîÑ AGGIORNA STATO TASTO: Tiene traccia se il tasto √® premuto */
            
            if (xVelocity === 0) {
              player.velocity.x = xVelocity;
              /* üõë VELOCIT√Ä ZERO: Per evento keyup */
              /* Quando si rilascia il tasto, ferma immediatamente il movimento */
            }
            player.velocity.x -= xVelocity;
            /* ‚¨ÖÔ∏è APPLICA VELOCIT√Ä: Muove a sinistra */
            /* Sottrae dalla velocit√† x per muoversi a sinistra */
            break;
            
          case "ArrowUp":
          case " ":
          case "Spacebar":
            /* ‚¨ÜÔ∏è SU/SPAZIO: Azione di salto */
            /* Pi√π casi gestiscono diversi tasti di salto */
            /* Sia la freccia su che la barra spaziatrice attivano il salto */
            
            player.velocity.y -= 8;
            /* ‚¨ÜÔ∏è VELOCIT√Ä DI SALTO: Si muove verso l'alto */
            /* Velocit√† y negativa significa movimento verso l'alto */
            /* Valore 8 crea un'altezza di salto soddisfacente */
            break;
            
          case "ArrowRight":
            /* ‚û°Ô∏è FRECCIA DESTRA: Muove il giocatore a destra */
            
            keys.rightKey.pressed = isPressed;
            /* üîÑ AGGIORNA STATO TASTO: Tiene traccia se il tasto √® premuto */
            
            if (xVelocity === 0) {
              player.velocity.x = xVelocity;
              /* üõë VELOCIT√Ä ZERO: Per evento keyup */
            }
            player.velocity.x += xVelocity;
            /* ‚û°Ô∏è APPLICA VELOCIT√Ä: Muove a destra */
            /* Aggiunge alla velocit√† x per muoversi a destra */
        }
      }
      
      /* üéÆ ===== FUNZIONI GESTIONE GIOCO ===== */
      
      const startGame = () => {
        /* üèÅ AVVIO GIOCO: Inizializza il gameplay */
        
        canvas.style.display = "block";
        /* üñºÔ∏è MOSTRA CANVAS: Rende il gioco visibile */
        /* Cambia il display da "none" a "block" */
        
        startScreen.style.display = "none";
        /* üôà NASCONDI SCHERMATA INIZIALE: Rimuove il menu */
        /* Una volta che il gioco inizia, non abbiamo pi√π bisogno del menu */
        
        animate();
        /* üé¨ AVVIA ANIMAZIONE: Inizia il game loop */
        /* Questo lancia il motore di gioco principale */
      }
      
      const showCheckpointScreen = (msg) => {
        /* üèÜ NOTIFICA CHECKPOINT: Mostra messaggio di traguardo */
        /* msg = testo personalizzato per diversi checkpoint */
        
        checkpointScreen.style.display = "block";
        /* üìù MOSTRA MESSAGGIO: Rende la notifica visibile */
        
        checkpointMessage.textContent = msg;
        /* üìù IMPOSTA TESTO: Aggiorna il contenuto del messaggio */
        /* Usa il parametro per personalizzare il messaggio */
        
        if (isCheckpointCollisionDetectionActive) {
          /* ‚è±Ô∏è VISUALIZZAZIONE TEMPORANEA: Solo se il gioco √® ancora attivo */
          
          setTimeout(() => (checkpointScreen.style.display = "none"), 2000);
          /* ‚è±Ô∏è RIMOZIONE TEMPORIZZATA: Nascondi dopo 2 secondi */
          /* setTimeout esegue la funzione dopo un ritardo in millisecondi */
          /* Arrow function con parentesi attorno ad una singola istruzione */
        }
      };
      
      /* üñ±Ô∏è ===== EVENT LISTENER: Gestione Input Utente ===== */
      
      startBtn.addEventListener("click", startGame);
      /* üé¨ LISTENER PULSANTE AVVIO: Inizia il gioco al click */
      /* Collega il pulsante HTML alla funzione JavaScript */
      
      window.addEventListener("keydown", ({ key }) => {
        /* üéÆ LISTENER PRESSIONE TASTI: Rileva quando i tasti vengono premuti */
        /* { key } usa la destrutturazione per estrarre la propriet√† key dall'evento */
        /* Molto pi√π pulito che scrivere (event) e poi event.key */
        
        movePlayer(key, 8, true);
        /* üèÉ‚Äç‚ôÇÔ∏è GESTISCI PRESSIONE TASTO: Muovi a velocit√† 8, tasto √® premuto */
        /* true = tasto √® premuto (evento keydown) */
      });
      
      window.addEventListener("keyup", ({ key }) => {
        /* üéÆ LISTENER RILASCIO TASTI: Rileva quando i tasti vengono rilasciati */
        /* Controparte a keydown - necessario per controlli fluidi */
        
        movePlayer(key, 0, false);
        /* üõë GESTISCI RILASCIO TASTO: Ferma movimento, tasto √® rilasciato */
        /* 0 = velocit√† zero (ferma movimento) */
        /* false = tasto √® rilasciato (evento keyup) */
      });
    </script>
  </body>
</html>

<!-- üéØ ===== RIASSUNTO DEL GIOCO PLATFORMER ===== -->
<!-- 
üéÆ ARCHITETTURA DEL GIOCO:
‚îÇ
‚îú‚îÄ‚îÄ üñ•Ô∏è STRUTTURA HTML
‚îÇ   ‚îú‚îÄ‚îÄ üìã Schermata iniziale con istruzioni
‚îÇ   ‚îú‚îÄ‚îÄ üèÜ Popup di notifica checkpoint
‚îÇ   ‚îî‚îÄ‚îÄ üñºÔ∏è Superficie di gioco Canvas
‚îÇ
‚îú‚îÄ‚îÄ üé® STILE CSS
‚îÇ   ‚îú‚îÄ‚îÄ üéÆ Componenti dell'interfaccia di gioco
‚îÇ   ‚îú‚îÄ‚îÄ üîò Stile pulsanti interattivi
‚îÇ   ‚îî‚îÄ‚îÄ üì± Design responsive per tutti gli schermi
‚îÇ
‚îî‚îÄ‚îÄ üß† MOTORE DI GIOCO JAVASCRIPT
    ‚îú‚îÄ‚îÄ üì¶ Programmazione Orientata agli Oggetti (Classi)
    ‚îÇ   ‚îú‚îÄ‚îÄ üßç Player con fisica e collisioni
    ‚îÇ   ‚îú‚îÄ‚îÄ üß± Piattaforme per la navigazione
    ‚îÇ   ‚îî‚îÄ‚îÄ üö© Checkpoint per gli obiettivi
    ‚îÇ
    ‚îú‚îÄ‚îÄ üéÆ Meccaniche di Gioco
    ‚îÇ   ‚îú‚îÄ‚îÄ ‚¨áÔ∏è Fisica di gravit√† e salto
    ‚îÇ   ‚îú‚îÄ‚îÄ üì∑ Sistema di scorrimento camera
    ‚îÇ   ‚îú‚îÄ‚îÄ üí• Rilevamento collisioni
    ‚îÇ   ‚îî‚îÄ‚îÄ üèÜ Sistema di checkpoint progressivo
    ‚îÇ
    ‚îî‚îÄ‚îÄ üîÑ Implementazione Tecnica
        ‚îú‚îÄ‚îÄ üé¨ Loop RequestAnimationFrame
        ‚îú‚îÄ‚îÄ üìè Dimensionamento proporzionale per responsivit√†
        ‚îú‚îÄ‚îÄ üéÆ Controlli da tastiera basati su eventi
        ‚îî‚îÄ‚îÄ üéØ Gestione dello stato per il progresso del gioco

Questo progetto dimostra i principi fondamentali dello sviluppo di giochi attraverso OOP!
Dalla simulazione fisica al rilevamento delle collisioni, √® un motore di mini-gioco completo!
-->
